/* Generated by CodeDescriptor 1.3.0.0714 */
/*
* Project Name      -> ST7565R
* Version           -> 1.0.1.0816
* Author            -> Hm @ Workstadion.: QP-01-02
* Build Date        -> 16.08.2017 07:08:38
* Description       -> Description
*
*
*
*/


#ifndef F_CPU
#define F_CPU	16e6
#endif

#include <avr/io.h>
#include <avr/interrupt.h>
#include <string.h>
#include <util/delay.h>

#include "st7565r.h"
#include "hard_def.h"

font_t font;

/* ONLY FOR INTERNAL OPERATIONAL */
static inline uint8_t swapBits(uint8_t byte)
{
	uint8_t ret = 0;
	
	for ( uint8_t i = 0 ; i < 8 ; i++ )
	{
		ret >>= 1;
		ret |= byte & 0x80;
		byte <<= 1;
	}
	return ret;
}




uint8_t calcXWidth(uint8_t x)
{
	return (font.fontPtr[2] * x);
}




void glcdSendData(uint8_t byte)
{
	uint8_t n = 0;
	
	GLCD_CTR_CS_PORT		&= ~(1<<GLCD_CTR_CS_bp);		// CS	= 0
	GLCD_CTR_A0_PORT		|=  (1<<GLCD_CTR_A0_bp);		// A0	= 1

	for (n = 0 ; n < 8 ; n++)
	{
		GLCD_CTR_SCK_PORT &= ~(1<<GLCD_CTR_SCK_bp);	// SCK = 0
		if (byte & 0x80)
		{
			GLCD_CTR_SD_PORT |= (1<<GLCD_CTR_SD_bp);	// SD = 1
		}
		else
		{
			GLCD_CTR_SD_PORT &= ~(1<<GLCD_CTR_SD_bp);	// SD = 0
		}
		byte <<= 1;

		GLCD_CTR_SCK_PORT |= (1<<GLCD_CTR_SCK_bp);	// SCK = 1
	}
	GLCD_CTR_CS_PORT |= (1<<GLCD_CTR_CS_bp);			// CS = 1
}

void glcdSendCmd(uint8_t cmd)
{
	uint8_t n = 0;
	
	GLCD_CTR_CS_PORT		&= ~(1<<GLCD_CTR_CS_bp);		// CS	= 0
	GLCD_CTR_A0_PORT		&= ~(1<<GLCD_CTR_A0_bp);		// A0	= 0

	for (n = 0 ; n < 8 ; n++)
	{
		GLCD_CTR_SCK_PORT &= ~(1<<GLCD_CTR_SCK_bp);	// SCK	= 0
		if (cmd & 0x80)
		{
			GLCD_CTR_SD_PORT |= (1<<GLCD_CTR_SD_bp);	// SD	= 1
		}
		else
		{
			GLCD_CTR_SD_PORT &= ~(1<<GLCD_CTR_SD_bp);	// SD	= 0
		}
		cmd <<= 1;
		//		_delay_ms(10);
		GLCD_CTR_SCK_PORT |= (1<<GLCD_CTR_SCK_bp);	// SCK	= 1
	}
	GLCD_CTR_CS_PORT |= (1<<GLCD_CTR_CS_bp);			// CS	= 1
}

void glcdInit(uint8_t cont)
{
	/* GLCD unit */
	GLCD_CTR_A0_DDR		|= (1<<GLCD_CTR_A0_bp);
	GLCD_CTR_CS_DDR		|= (1<<GLCD_CTR_CS_bp);
	GLCD_CTR_SCK_DDR	|= (1<<GLCD_CTR_SCK_bp);
	GLCD_CTR_SD_DDR		|= (1<<GLCD_CTR_SD_bp);
	GLCD_CTR_RESET_DDR	|= (1<<GLCD_CTR_RESET_bp);

 	GLCD_CTR_CS_PORT	&= ~(1<<GLCD_CTR_CS_bp);

	GLCD_CTR_RESET_PORT	&= ~(1<<GLCD_CTR_RESET_bp);	
	GLCD_CTR_RESET_PORT	|= (1<<GLCD_CTR_RESET_bp);	

	for( uint8_t i = 0 ; i < sizeof( glcd_config ) ; i++ )
	{
		if( ( i == 10 ) && ( cont != 0 ) )
		{
			glcdSendCmd( cont );
		}
		else
		{
			glcdSendCmd( glcd_config[i] );
		}
		
	}
	
	glcdClear();
}

void glcdSetPageColumn(uint8_t pageAddr, uint8_t column)
{
	/*
	*	Sende Kommando für die Reihen
	*/
    glcdSendCmd(((pageAddr & 0x0F ) | 0xB0));
     
    /*
    *   Baue das Kommando für die Zeile (High Byte)
    */
    glcdSendCmd((((column&0xF0)>>4)) | 0x10);
     
    /*
    *   Adresse (Low Byte)
    */
    glcdSendCmd(column & 0x0F);
}

void glcdSendBuffer(uint8_t *image)
{
	/*
	*	Buffer Size = GLCD_HIGH_SIZE * GLCD_WIDTH_SIZE = 8092 Bytes
	*/
	for ( uint8_t i = 0 ; i < GLCD_PAGE_SIZE ; i++ )
	{
		glcdSetPageColumn( 7 - i  , 0 );
		for ( uint8_t x = 0 ; x < GLCD_WIDTH_SIZE ; x++ )
		{
			glcdSendData(image[x]);
		}
		image += GLCD_WIDTH_SIZE;
	}
}


void glcdFill(void)
{
	for ( uint8_t page = 0 ; page < GLCD_PAGE_SIZE ; page++ )
	{
		glcdSetPageColumn( page , 0 );
		for ( uint8_t col = 0 ; col < GLCD_WIDTH_SIZE ; col++ )
		{
			glcdSendData(0xFF);
		}
	}
}

void glcdClear(void)
{
	for ( uint8_t page = 0 ; page < GLCD_PAGE_SIZE ; page++ )
	{
		glcdSetPageColumn( page , 0 );
		for ( uint8_t col = 0 ; col < GLCD_WIDTH_SIZE ; col++ )
		{
			glcdSendData(0x00);
		}
	}
}

void glcdReset(void)
{
	glcdSendCmd(0xE2);
}



static inline font_t calcFontStart(uint8_t c, font_t font, const uint8_t __flash *fontPtr)
{
	#define OFFSET_SETTING_INFOS	8
	
	uint8_t charNum = 0;
	
	font.width = fontPtr[(c-font.fontPtr[4])+OFFSET_SETTING_INFOS]; // Breite des Zeichens
	
	font.indexNum = font.fontPtr[6]; // Offset (ab hier beginnen die Pixel Daten)
	
	if ( font.fontPtr[7] == 1 ) // Fonts mit fester Breite
	{
		for(	; charNum <= (c - font.fontPtr[4])-1 ; charNum++)
		{
			font.indexNum += (font.fontPtr[2] * ((font.fontPtr[3] / 8)+1)); // Font breite berechnen
		}
	}
	else if ( font.fontPtr[7] == 0)
	{
		for(	; charNum <= (c - font.fontPtr[4])-1 ; charNum++)
		{
			font.indexNum += (fontPtr[charNum + OFFSET_SETTING_INFOS] * 2 ); // Anstatt *2 schieben wir hier einfach
		}
	}
	
	return font;
}

void glcdPrintImage(const __flash unsigned char *image, uint16_t sizeofimage, uint8_t x, uint8_t y)
{	
 	uint16_t column = image[2];
	uint16_t page = 0;
	
	glcdSetPageColumn((x/8),y);
	for ( ; page < ( ( image[1] / 8 ) + 2 ) ; page++ )
	{
		for ( ; column < (uint16_t)((image[0] * page)+image[2]) && (column < sizeofimage) ; column++)
		{
			glcdSendData(swapBits((image[column])));
		}
		glcdSetPageColumn((x/8)-(page),y);
	}
}

void glcdSetFont(const uint8_t __flash *chooseFontPtr)
{
	font.fontPtr = chooseFontPtr;
}

void glcdPutc(char c, uint8_t y, uint8_t x)
{	
	uint16_t	index = 0;	
	uint8_t		page = 0;
	
	font = calcFontStart( c , font , font.fontPtr );	
	
	#define FONT_IS_FIXED			0x01
	#define FONT_IS_NOT_FIXED		(!(FONT_IS_FIXED))

	/*
	*	Ist wichtig für den Abstand der Zeichen!
	*/
	if (font.fontPtr[7] == FONT_IS_FIXED)
	{
		font.width = font.fontPtr[2];
	}
	
	glcdSetPageColumn((y/8),x);
	for ( page = 0 ; page < ((font.fontPtr[3] / 8 ) + 2 ) ; page++ ) // Berechne die Anzahl der benötigten Reihen
	{	
		/*
		*	Bei Fonts die höher als 8 Pixel sind, müssen die letzten Zeilen dementprechend behandelt werden.
		*	Es entsteht eine Lücke, weil das Font nicht kompatibel zu einem senkrecht zeichnenden Display ist
		*/
		if ( ( page == ( ( ( font.fontPtr[3] / 8 ) + 2 ) - 1 ) ) && font.fontPtr[3] > 8 )
		{
			for ( ; index < ( font.width * page ) ; index++)
			{
				glcdSendData(swapBits(font.fontPtr[font.indexNum+index])<<((page * 8) - font.fontPtr[3]));
			}
			break;
		}
		
		for ( ; index < ( font.width * page ) ; index++ )
		{	
			glcdSendData(swapBits(font.fontPtr[font.indexNum+index]));
		}
		glcdSetPageColumn(( y / 8 ) - page,x);
	}
}

void glcdPuts(char *str, uint8_t y , uint8_t x)
{
	uint16_t space = 0;
	while (*str)
	{
		glcdPutc(*str++,y,space+x);
		space += (font.width) + 1; // nächste Schreibposition anhand der größe vom Zeichen summieren.
	}
}


void glcdSetPixel(uint8_t y , uint8_t x)
{
	//	uint8_t index 	= y / 8;
	//	uint8_t yBitPos = y % 8;
	
	glcdSetPageColumn(y/8,x);
	glcdSendData(1<<(y%8));
}

void glcdClearPixel(uint8_t y, uint8_t x)
{
	// VRAM[x][y] &= ~1<<(x%8);
	
	// 	glcdSetPageColumn(x/8,y);
	// 	glcdSendData(0<<(x%8));
}

void glcdDrawRect(uint8_t y, uint8_t x, uint8_t h, uint8_t w, uint8_t *buff)
{
	glcdSendBuffer(buff);
}

void glcdDrawLine(uint8_t y, uint8_t x, uint8_t leng)
{
	glcdSetPageColumn(7-y,x);
	for (uint8_t c = 0 ; c < leng ; c++)
	{
		glcdSetPixel(y,c);
	}
}

void glcdClearLine(uint8_t y, uint8_t x, uint8_t leng)
{
	for (uint8_t c = 0 ; c < leng ; c++)
	{
		glcdPutc( ' ' , GLCD_CALC_PAGE( y ) , calcXWidth( x + c )  );
	}
}

