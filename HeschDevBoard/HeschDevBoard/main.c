/* Generated by CodeDescriptor 1.3.0.0714 */
/*
* Project Name      -> DevBoard
* Version           -> 1.0.0.0817
* Author            -> Hm @ Workstadion.: QP-01-02
* Build Date        -> 17.08.2017 15:12:04
* Description       -> Description
*
*
*
*/


/* 
*	Arbeitsfrequenz 
*/
#define F_CPU	16e6

/* 
*	9600 baud 
*/
#define UART_BAUD_RATE			9600

/* 
*	Berechnet die größe eines Arrays
*/ 
#define ARRAY_SIZE(array) ((sizeof(array) / sizeof(array[0])))

/*
*	PWM Frequenz
*/
#define PWM_FREQUENZ	100

/*
*	Speert die Anwendung nach x mal 
*/
#define LOCK_SOFTWARE_AFTER_X_TURN_ON	500

/*
*	Administrator Passwort für Systemänderungen
*/
#define ADMIN_PSWD	"J218"

/*
*	EEPROM Einstellungen
*/
#define EEP_IS_INIT				0x3C
#define EEP_LENG_OF_SERNR		7
#define EEP_LENG_OF_USER_NAME	16

/*
*	Sprungmarke für einen Softwarereset (KEIN HARDWARE RESET!)
*/
void(*restart)(void) = 0;

/*
*	Minimale Helligkeit bei inaktivität
*/
#define DISP_MIN_PWM		0

#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <util/crc16.h>
#include <stdbool.h>
#include <avr/eeprom.h>





#include "Hardware Libs/hard_init.h"
#include "Hardware Libs/hard_def.h"
#include "Hardware Libs/i2cmaster.h"
#include "Hardware Libs/uart.h"
#include "Hardware Libs/rx8564.h"
#include "Hardware Libs/st7565r.h"
#include "Hardware Libs/sts3x.h"


#include "Glcd Fonts/font_arial14.h"
#include "Glcd Fonts/corsiva_12.h"
#include "Glcd Fonts/fixed_num_8x16.h"
#include "Glcd Fonts/fixed_num_15x31.h"
#include "Glcd Fonts/System_5x7.h"


#include "Bitmaps/key.h"
#include "Bitmaps/schloss.h"


#include "strings.h"
#include "ttostr.h"
#include "build_info.h"
#include "cmd.h"
#include "convert.h"
#include "app_state.h"


enum uartMainCmd
{
	UART_CMD_BOOT_UP,
	UART_CMD_RELAIS,

	UART_CMD_DATE,	
	UART_CMD_TIME,
	
	UART_CMD_SRN,
	UART_CMD_USERNAME,
	
	UART_CMD_EEPROM,
	
	NUMB_OF_UART_MAIN_CMD		
};

enum uartSubCmd
{
	UART_CMD_READ,
	UART_CMD_WRITE,
	UART_CMD_CLEAR,
	
	NUMB_OF_UART_SUB_CMD
};

typedef struct  
{
	const uint8_t main[NUMB_OF_UART_MAIN_CMD];
	uint8_t sub[NUMB_OF_UART_SUB_CMD];
	
}uartCmd_t;

uartCmd_t uartCmd =
{
	/*
	*	UART Haupt Kommandos
	*/
	{
		[UART_CMD_BOOT_UP]	= 'B',
		[UART_CMD_RELAIS]	= 'K',
		[UART_CMD_DATE]		= 'D',
		[UART_CMD_TIME]		= 'U',
		[UART_CMD_SRN]		= 'S',
		[UART_CMD_USERNAME]	= 'N',
		[UART_CMD_EEPROM]	= 'E',
	},
	
	/*
	*	UART Unter Kommandos
	*/
	{
		[UART_CMD_READ]		= 'r',
		[UART_CMD_WRITE]	= 'w',
		[UART_CMD_CLEAR]	= 'c',
	},
};


typedef union
{
	/*
	*	Hier werden Status Bits gesetzt oder gelöscht (@app_state.h)
	*/
	state_t		state;
	
	/*
	*	state teilt sich mit result den Speicherbereich, so kann man die ganzen
	*	Status / Error Bits aufeinmal zurücksetzen
	*/
	uint16_t	result;
}app_u;

typedef struct
{	
	/*
	*	GF = GlobalFlag! Hier können irgendwelche Flags gesetzt werden
	*/
	uint8_t		GF;
	
	/*
	*	Zähler für das scrollen vom Newsticker
	*/
	uint32_t	scrollTime;
	
	/*
	*	Zähler zum dimm der Hintergrundbeleuchtung
	*/
	uint32_t	autoDimm;
	uint32_t	autoDimmDelay;
	uint8_t		autoDimmEnable :1;
	
	/*
	*	Administrator Passwort
	*/
	uint8_t		adminPswd[5];
	
	/*
	*	Struktur für Meldungen / Fehlermeldungen
	*/
	app_u		state;	

}sys_t;
sys_t sys;

typedef struct  
{
	
	/*
	*	Prüft ob der EEPROM initalisiert wurde 
	*	EEPROM initalisiert = 0x3C!
	*/
	uint8_t init;
	
	/*
	*	Zählt die Einschaltvorgänge
	*/
	uint16_t startUpDevice;
		
	/*
	*	Benutzernamen 
	*/
	uint8_t userNameLen;
	char	userName[EEP_LENG_OF_USER_NAME];
	
	/*
	*	Seriennummer
	*/
	char	srn[EEP_LENG_OF_SERNR];
	
	/*
	*	Kontrast vom Display
	*/
	uint8_t contrast;
	
	/*
	*	Helligkeit vom Display
	*/
	uint8_t brightness;
	
	/*
	*	Automatisches dimmen des Displays
	*/
	uint8_t autoDimmEnable;
	
}eep_t;

eep_t EEMEM eep;
eep_t eepRAM;
	
typedef struct
{
	/*
	*	Aktuelle Checksumme vom empfangenen String
	*/
	uint8_t		buildFrmStr;
	
	/*
	*	Wenn an dem Empfangenen String eine Checksumme hängt, zeigt dieser
	*	Zeiger darauf
	*/
	char		*beginPtr;
	
	/*
	*	Checksummen Fehler
	*/
	uint16_t	err;
}crc_t;
crc_t crc;

typedef struct
{
	/*
	*	Speicher für die empfangenen Bytes
	*/
	char rx[UART_RX_BUFFER_SIZE];
	
	/*
	*	Zählt die empfangenen Bytes
	*/
	uint16_t rxCnt;
	
	/*
	*	Zählt die gesendeten Bytes
	*/
	uint16_t txCnt;
	
}uart_t;
uart_t uart;

typedef struct
{
	/*
	*	Zähler Tabelle für das incrementieren vom Encoder
	*/
	const int8_t Table[16];
	
	/*
	*	Aktueller Zählerstand vom Encoder
	*/
	int8_t		 result;
	
	/*
	*	Letzter Zählerstand vom Encoder (darf nicht weiter benutzt werden!)
	*/
	int8_t		 Last;
	
}enc_t;
volatile enc_t encoder=
{
	.Table = { 0 , 0 , -1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , -1 , 0 , 0 },	
};


typedef struct    
{
	/*
	*	PWM Zählerwert für die rote LED vom Grafikdisplay
	*/
	uint8_t red;
	
	/*
	*	PWM Zählerwert für die grüne LED vom Grafikdisplay
	*/
	uint8_t green;
	
	/*
	*	PWM Zählerwert für die blue LED vom Grafikdisplay
	*/
	uint8_t blue;
}glcd_t;


typedef struct
{
	glcd_t glcd;
	
	/*
	*	Wird die PWM gerade hoch gefadet oder runter?
	*
	*	fadeUp.: 1 == Hoch faden
	*	fadeUp.: 0 == Runter faden
	*/
	uint8_t  fadeUp :1;
	
}pwm_t;
volatile pwm_t pwm=
{
	.fadeUp				= 0,
	.glcd.blue			= 100,
	.glcd.red			= 100,
	.glcd.green			= 100,
};


#define SET_PWM( R , G , B )				(pwm.glcd.red	= R),\
											(pwm.glcd.green	= G),\
											(pwm.glcd.blue	= B);

#define SET_COLOR_OFF						SET_PWM( 0 , 0 , 0	 )
#define SET_COLOR_RED						SET_PWM( 100 , 0 , 0 )
#define SET_COLOR_GREEN						SET_PWM( 0 , 100 , 0 )
#define SET_COLOR_BLUE						SET_PWM( 0 , 0 , 100 )

#define GLCD_SET_BRIGHTNESS(BRIGHTNESS)		SET_PWM(BRIGHTNESS,BRIGHTNESS,BRIGHTNESS)

static inline void waitEEPIsBusy(void)
{
	while(eeprom_is_ready() != 1);
}

rx8564_t rtc;


/*
*	Globaler Speicher für verschiedene Berechnungen.
*/
uint8_t buffer[25]="";
	
/*
*	Newsticker Speicher (Speicher reserviert für Laufschrift!)
*/
typedef struct  
{
	char		newsBuff[160];
	uint8_t		errorStrLeng;
	uint8_t		staticStrLeng;
	uint8_t		timeDateStrLeng;
	
}newsticker_t;
newsticker_t newsticker;
	
typedef struct  
{
	/*
	*	Zu einer bestimmten Uhrzeit gemessene Temperatur
	*/
	int8_t temp;
	
	/*
	*	Uhrzeit des gemessenen Wertes
	*/
	char time[9];
	
}tempStamp_t;

tempStamp_t stamp[2] =
{
	{ 0 , "00:00:00"},
	{ 0 , "10:00:00"},
};
	
	

uint16_t			_delay;
uint8_t				activeRelais;	


/*
*	NUR DEN STRING ÜBERGEBEN AB DEM PUNKT
*	WO DIE ZAHLEN BEGINNEN.
*/
inline void removeLeadingNumbs(char *str,uint8_t wanted)
{
	/*
	*	Zeiger um später die Adresse von "str"
	*	zwischen zu speichern.
	*/
	char *p;
	
	/*
	*	Beinhaltet die Anzahl vorkommender Zahlen im Suchstring.
	*/
	uint8_t fnd=0;
	
	/*
	*	Zählen der im String vorkommenden Zahlen.
	*/
	for( p = str ; *p ; p++)
	{
		if ( *p >= '0' && *p <= '9' )
		{
			fnd++;
		}
	}
	

	while(*str)
	{
		while(*str == wanted)
		{
			/*
			*	Letzte Ziffer nicht überschreiben
			*/
			if(fnd-- == 1)
			{
				return;
			}
			
			for ( p = str ; *p ; p++ )
			{
				*p = *(p+1);
			}
		}
		
		/*
		*	Kommt dannach eine Zahl außer '0',
		*	brechen wir die weitere Suche ab.
		*/
		if(*(str) != '0')
		{
			return;
		}
		
		str++;
	}
}

static inline uint16_t checkMaxValue(uint16_t val, uint16_t max)
{
	if( val >= max )
	{
		return 0;
	}
	return val;
}

static inline int16_t checkMinValue(int16_t val, int16_t min)
{
	if( val < min )
	{
		return min;
	}
	return val;
}

volatile uint32_t sts3xRead;
static inline void refreshTemp(void)
{
	if (sts3xRead > 50000)
	{
		rtcGetData(&rtc);
		sts3x.actual = sts3x_get_temp();
			
		if ( sts3x.actual < sts3x.lowest )
		{
			sts3x.lowest = sts3x.actual;
			stamp[0].temp = sts3x.lowest;
			strcpy ( stamp[0].time , bcd_ttostr(rtc.hour,rtc.minute,rtc.second) );
		}	
		else if ( sts3x.actual > sts3x.highest )
		{
			sts3x.highest = sts3x.actual;
			stamp[1].temp = sts3x.highest;
			strcpy ( stamp[1].time , bcd_ttostr(rtc.hour,rtc.minute,rtc.second) );
		}
		sts3xRead = 0;
	}
}

void valToStr(char *b, uint16_t val)
{
	*b++ = (((val / 10000) % 10)  + '0');
	*b++ = (((val / 1000)	% 10) + '0');
	*b++ = (((val / 100)	% 10) + '0');
	*b++ = (((val / 10)	% 10)     + '0');
	*b++ = ((val % 10)		      + '0');
	*b = '\0';
}

void setRelais(uint8_t Kx)
{
	activeRelais = Kx;
	
	/*
	*	Setze Relais
	*/
	RELAIS_PORT1_PORT = ( Kx << 2 );
	RELAIS_PORT2_PORT = ( ( Kx & 0xC0 ) >> 4 );
}

void timerInit(void)
{	
	/*
	*	Frequenzteiler einstellen und den Modus konfigurieren
	*	CTC Modus = 1 (Compare Match Interrupt)
	*/
	TCCR1B |= ((1<<WGM12) | (1<<CS10));
	
	/*
	*	Interrupt aktivieren
	*/
	TIMSK  |= ( 1 << OCIE1A );
	
	/*
	*	Comapre Wert einstellen
	*/
	OCR1A   = ( (uint16_t)( F_CPU / 1 / 15000 ) );	
}

char *putCrc8(crc_t *crc)
{
	static char tmp[14] = "crc.:";
	valToStr(&tmp[5],crc->buildFrmStr);	
	removeLeadingNumbs(&tmp[5],'0');
	strcat(tmp,"\r\n");
	
	return tmp;
}

uint8_t crc8Update (uint8_t inCrc, uint8_t inData)
{
	uint8_t   i = 0;
	static uint8_t data = 0;

	data = inCrc ^ inData;

	for ( i = 0; i < 8; i++ )
	{
		if (( data & 0x80 ) != 0 )
		{
			data <<= 1;
			data ^= 0x07;
		}
		else
		{
			data <<= 1;
		}
	}
	return data;
}

bool readRingBuff(uart_t *u)
{
	static uint8_t index = 0;
	
	/*
	*	Neustes Byte aus dem Ringpuffer abholen
	*/
	uint16_t c = uart_getc();
	
	/*
	*	Wenn keine neuen Daten vorhanden, direkt wieder zurück!
	*/
	if ( c & UART_NO_DATA)
	{
		return false;
	}
	
	/*
	*	Ist ein Fehler aufgetreten?
	*/
	if ( c > UART_NO_DATA)
	{
		index = 0; 
		return false;
	}
	
	/*
	*	Status und Error Bits ausmaskieren
	*/
	c &= 0x00FF;
	
	/*
	*	Übertragungsende?
	*/
	if (c == '\n' || c == '\r')
	{
		u->rx[index] = '\0';
		index = 0; 
		return true;
	}
	
	/*
	*	Daten in unseren neuen Puffer zwischen speichern
	*/
	if (index >= UART_RX_BUFFER_SIZE)
	{
		index = 0;
	}
	else
	{
		u->rx[index++] = (uint8_t)c;	
		u->rxCnt++;
	}
	
	return false;
}

void glcdPrintInfo(char *ser)
{
	glcdPuts( (char*)board.id[ID_PROJECT] , GLCD_CALC_PAGE( 0 ) , 0 );

	glcdPuts( (char*)board.id[ID_HARDWARE_DATE] , GLCD_CALC_PAGE( 2 ) , 0 );

	glcdPuts("Ver.:", GLCD_CALC_PAGE( 3 ) , 0 );
	glcdPuts( board.buildSwVer() , GLCD_CALC_PAGE( 3 ) , calcXWidth( 6 ) );
	
	glcdPuts("SerNr.:" , GLCD_CALC_PAGE( 4 ) , 0 );
	glcdPuts(ser,GLCD_CALC_PAGE(4),calcXWidth(9));
	
	glcdPuts((char*)board.id[ID_MADE_BY],GLCD_CALC_PAGE(5),0);
}

char *checkSerialNumber(char *ser, sys_t *inf)
{
	char *p;

	for( p = ser ; *p ; p++ )
	{		
		if( ! ( *p >= '0' && *p <= '9' ) )
		{
			
			inf->state.state.SerNrErr = 1;
		
			return NULL;		
		}
	}
	return ser;
}

char *serialNumberRW(char *ser, eep_t *e)
{	
	/*
	*	Offset.: -2 ! Hier werden die beiden Kommandos für "lesen / schreiben" abgezogen (s(r/w))
	*/
	uint8_t leng = strlen(ser) - 2; 
	
	if (leng != (EEP_LENG_OF_SERNR -1 ) && (ser[1] == 'W' || ser[1] == 'w'))
	{
		return NULL;
	} 
	
	if (checkSerialNumber(&ser[2],&sys) == NULL)
	{
		return NULL;
	}
	
	switch (ser[1])
	{
		case 'w':
		case 'W':
		{
			eeprom_write_block(&ser[2] , e->srn , (EEP_LENG_OF_SERNR - 1));
			waitEEPIsBusy();
			restart();
		}break;
		
		case 'r':
		case 'R':
		{
			eeprom_read_block((char*)ser , e->srn , (EEP_LENG_OF_SERNR - 1));
		}break;
	}
	return ser;
}

char *crcFromString(char *str, crc_t *c)
{	
	char *search = str;
	
	/* 
	*	Sucht den String ab ob eine Checksumme mit gesendet wurde. 
	*	Wenn ja, wird nur CRC bis '#' gebildet!
	*/	
	c->beginPtr = strchr(search,'#');
	
	/* 
	*	Checksumme wurde mit gesendet!
	*/
	if (c->beginPtr != NULL)
	{		
		while((*str != '#')){c->buildFrmStr = crc8Update(c->buildFrmStr,*str++);}
		if(*++c->beginPtr != c->buildFrmStr)
		{
			c->err++;
			return (char*)(board.id[ID_CRC_ERR]);
		}
	}
	
	/*  
	* Checksumme wurde nicht mit gesendet, CRC auf den ganzen String bilden.
	*/
	else
	{
		while((*str != '\0')){c->buildFrmStr = crc8Update(c->buildFrmStr,*str++);}		
	}
	
	return NULL;
}

uint8_t uartProcess(uart_t *u)
{	
	#define CMD_OK		(1<<0)
	#define CMD_FAIL	(1<<1)
	
	uint8_t handlingErr = 0;
		
	if(readRingBuff(u))
	{					
		/*
		*	Lösche alten CRC Wert von dem letzten empfangenen String.
		*/
		crc.buildFrmStr=0;
			
		/* 
		*	Beginn eines Kommandos suchen und beginnen zu bearbeiten.
		*	Sollte ein Kommando gefunden werden (beginnt mit '-'), werden
		*	Ab dem Startzeichen "20" Bytes eingelesen.
		*/	
		if (srchCmd(u->rx,"-",20) == 0)
		{	
			/*
			*	Bildet die Checksumme von dem ganzen Kommando,
			*	bis auf die Checksumme selbst die empfangen wurde.
			*/
			char *strCRC = crcFromString(u->rx,&crc);
			if (strCRC != NULL)
			{
				uart_puts(strCRC);
				return 1;
			}
			
			
			
			
			if ( u->rx[1] == uartCmd.main[UART_CMD_RELAIS] )
			{
				uint8_t msk = atoi((char*)&u->rx[2]);
				setRelais(msk);	
				sys.state.state.newRelaisSet = 1;
				handlingErr=CMD_OK;				
			}
			
			else if( u->rx[1] == uartCmd.main[UART_CMD_SRN])
			{
				char *ret = serialNumberRW(&u->rx[1], &eep);
					
				handlingErr = CMD_OK;
				if ( ret != NULL )
				{
					uart_puts(ret);
					uart_puts("\r\n");
				}
				else
				{
					handlingErr = CMD_FAIL;
				}
			}
			
			else if( u->rx[1] == uartCmd.main[UART_CMD_TIME] )
			{
				uint8_t time_[4] = "";
					
				/*
				*	Uhrzeit vom String einsammeln.
				*/
				time_[0] = 	atoi(&u->rx[2]); // Stunden
				time_[1] = 	atoi(&u->rx[5]); // Minuten
				time_[2] = 	atoi(&u->rx[8]); // Sekunden 
					
				/*
				*	Überläufe überprüfen.
				*/						
 				time_[0] = checkMaxValue(time_[0],24);		
 				time_[1] = checkMaxValue(time_[1],59);
 				time_[2] = checkMaxValue(time_[2],59);
					
					
				rtcSetTime(time_[0],time_[1],time_[2]);
				sys.state.state.newTimeSet = 1;
				handlingErr=CMD_OK;				
			}
			
			else if(u->rx[1] == uartCmd.main[UART_CMD_DATE])
			{
				uint8_t date_[4];
					
				/*
				*	Datum vom String einsammeln.
				*/
				date_[0] = atoi(&u->rx[2]); // Tag
				date_[2] = atoi(&u->rx[5]); // Monat
				date_[3] = atoi(&u->rx[8]); // Jahr
				date_[1] = atoi(&u->rx[11]);// Name des Tages
					
				/*
				*	Überläufe überprüfen.
				*/
				date_[0] = checkMaxValue(date_[0],31);
				date_[2] = checkMaxValue(date_[2],12);
				date_[3] = checkMaxValue(date_[3],99);
				date_[1] = checkMaxValue(date_[1],7);
					
				rtcSetDate(date_[0],date_[1],date_[2],date_[3]+2000);
				sys.state.state.newDateSet = 1;
				handlingErr=CMD_OK;				
			}
			
			else if (u->rx[1] == uartCmd.main[UART_CMD_USERNAME])
			{					
				memset(buffer,0,sizeof(buffer));
				
				if ( u->rx[2] == uartCmd.sub[UART_CMD_READ] )
				{
					eeprom_read_block((char*)buffer,(char*)eep.userName,EEP_LENG_OF_USER_NAME);
					strcat( (char*)buffer , "\r\n" );
					uart_puts( (char*)buffer );
						
					handlingErr = CMD_OK;					
				}
				else if ( u->rx[2] == uartCmd.sub[UART_CMD_WRITE] )
				{
					uint8_t nameLeng = strlen(&u->rx[3]);
						
					if(nameLeng > (EEP_LENG_OF_USER_NAME - 1))
					{
						handlingErr = CMD_FAIL;
						return 1;
					}
						
					sys.state.state.newUserName = 1;
						
					eeprom_update_byte(&eep.userNameLen , nameLeng);
					waitEEPIsBusy();
						
					eeprom_update_block((char*)&u->rx[3],(char*)eep.userName,EEP_LENG_OF_USER_NAME);
					waitEEPIsBusy();
						
					restart();					
				}
				
			}
			
			else if (u->rx[1] == uartCmd.main[UART_CMD_EEPROM])
			{
				if ( u->rx[2] == uartCmd.sub[UART_CMD_READ] )
				{
					valToStr((char*)buffer,eepRAM.startUpDevice);
					removeLeadingNumbs((char*)buffer,'0');
					uart_puts("EEP Lock.: ");
					uart_puts((char*)buffer);
					uart_puts("\r\n");
					handlingErr = CMD_OK;					
				}
				else if ( u->rx[2] == uartCmd.sub[UART_CMD_CLEAR] )
				{
					eeprom_write_word(&eep.startUpDevice,0);
					waitEEPIsBusy();
					restart();
				}

			}
			else
			{
				uart_puts(board.id[ID_MENUE_UNKNOWN_CMD]);
			}
		}
		
		if ( ( ( handlingErr & CMD_OK ) == CMD_OK ) )
		{
			uart_puts(board.id[ID_OK]);
		}
		
		if ( ( ( handlingErr & CMD_FAIL ) == CMD_FAIL ) )
		{
			uart_puts(board.id[ID_ERR]);
		}
		
		strcpy((char*)buffer,"\r\n");
		strcat((char*)buffer,putCrc8(&crc));
		uart_puts((char*)buffer);
		
	}// end if	
		
	return 0;
}

uint8_t *i2cScan(uint8_t *buffer)
{
	uint8_t addr = 0;
	for ( addr = 0 ; addr < 255 ; addr++ )
	{
 		if (!(i2c_rep_start(addr)))
		{ 
			*buffer++ = (uint8_t)addr;
		}
	}*buffer++ = '\0';	

	return buffer;
}

uint8_t setTime( uint8_t *buff )
{
	#define TIME_OFFSET 35
	
	rtcGetData(&rtc);
	buff[0] = bcdToDec(rtc.hour);
	buff[1] = bcdToDec(rtc.minute);
	buff[2] = bcdToDec(rtc.second);

	for ( uint8_t x = 0 ; x < 3 ; x++ )
	{
		encoder.result = 0;
		
		while (1)
		{
			buff[x] += encoder.result;
			
			if (encoder.result)
			{
				encoder.result = 0;
				_delay=0;
			}
			
			switch(x)
			{
				case 0: {buff[x] = checkMaxValue(buff[x],24);}break;
				case 1: {buff[x] = checkMaxValue(buff[x],59);}break;
				case 2: {buff[x] = checkMaxValue(buff[x],59);}break;
			}
			
			if ( _delay++ < 400 )
			{
				glcdPuts(dec_ttostr(buff[0],buff[1],buff[2]),GLCD_CALC_PAGE(3),TIME_OFFSET);
			}
			else if ( _delay > 600 )
			{
				switch(x)
				{
					case 0: {glcdPuts(dec_ttostr(0xff,buff[1],buff[2]),GLCD_CALC_PAGE(3),TIME_OFFSET);}break;
					case 1: {glcdPuts(dec_ttostr(buff[0],0xff,buff[2]),GLCD_CALC_PAGE(3),TIME_OFFSET);}break;
					case 2: {glcdPuts(dec_ttostr(buff[0],buff[1],0xff),GLCD_CALC_PAGE(3),TIME_OFFSET);}break;
				}
			}
			_delay = checkMaxValue(_delay,800);

			if(!(ENC_SWITCH_PORT & 1<<ENC_SWITCH_bp))
			{
				_delay_ms(25);
				while (!(ENC_SWITCH_PORT & 1<<ENC_SWITCH_bp));
				break;
			}
		}
	}
		
	return 0;
}

uint8_t setDate( uint8_t *buff )
{
	#define DATE_OFFSET 25

	rtcGetData(&rtc);
	buff[0] = bcdToDec(rtc.day);
	buff[1] = bcdToDec(rtc.month);
	buff[2] = bcdToDec(rtc.year);
	buff[3] = bcdToDec(rtc.dayName);
	
	for ( uint8_t x = 0 ; x < 4 ; x++ )
	{
		while(1)
		{
			buff[x] += encoder.result;
			
			if (encoder.result)
			{
				encoder.result = 0;
				_delay = 0;
			}
			
			switch(x)
			{
				case 0 : {	buff[x] = checkMaxValue(buff[x],31)	;}break;
				case 1 : {	buff[x] = checkMaxValue(buff[x],12)	;}break;
				case 2 : {	buff[x] = checkMaxValue(buff[x],99)	;}break;
				case 3 : {	buff[x] = checkMaxValue(buff[x],7)		;}break;
				
				default:break;
			}
			
			if ( _delay++ < 200 )
			{
				glcdPuts(dec_dtostr(buff[0],buff[1],(uint16_t)2000+buff[2],buff[3]),GLCD_CALC_PAGE(3),DATE_OFFSET);
			}
			else if ( _delay > 400 )
			{
				switch(x)
				{
					case 0 : {glcdPuts(dec_dtostr(0xff,buff[1],(uint16_t)2000+buff[2],buff[3]),GLCD_CALC_PAGE(3),DATE_OFFSET);}break;
					case 1 : {glcdPuts(dec_dtostr(buff[0],0xff,(uint16_t)2000+buff[2],buff[3]),GLCD_CALC_PAGE(3),DATE_OFFSET);}break;
					case 2 : {glcdPuts(dec_dtostr(buff[0],buff[1],0xffff,buff[3]),GLCD_CALC_PAGE(3),DATE_OFFSET);}break;
					case 3 : {glcdPuts(dec_dtostr(buff[0],buff[1],(uint16_t)2000+buff[2],0xff),GLCD_CALC_PAGE(3),DATE_OFFSET);}break;
					
					default:break;
				}
				
			}
			_delay = checkMaxValue(_delay,600);
			
			if(!(ENC_SWITCH_PORT & 1<<ENC_SWITCH_bp))
			{
				_delay_ms(25);
				while (!(ENC_SWITCH_PORT & 1<<ENC_SWITCH_bp));
				break;
			}
		}
	}	
	return 0;
}


void glcdScrollMsg(uint8_t posX, char *msg)
{
	#define DISPLAY_WIDTH	26
	
	static int8_t x = DISPLAY_WIDTH;
	uint8_t col = 0,spalte = 0;
	
	if (x-- <= (int8_t)strlen(msg)*-1)
	x = DISPLAY_WIDTH;
	
	glcdSetPageColumn( 7 - posX , spalte = 0);
	
	if (x>=0)
	{
		while((col++ < x) && (col < (DISPLAY_WIDTH)))
		{
			glcdPutc(' ',posX,calcXWidth(spalte++));
		}
		
		while ((*msg) && (col++ < (DISPLAY_WIDTH)))
		{
			glcdPutc(*msg++,posX,calcXWidth(spalte++));
		}
		
		while (col++ < (DISPLAY_WIDTH))
		{
			glcdPutc(' ',posX,calcXWidth(spalte++));
		}
	}
	else
	{
		if ((x+strlen(msg)) <= 0)
		{
			while (col++ < (DISPLAY_WIDTH))
			{
				glcdPutc(' ',posX,calcXWidth(spalte++));
			}
		}
		else
		{
			uint8_t i = abs(x);
			while ((msg[i]) && (col++ < (DISPLAY_WIDTH)))
			{
				glcdPutc(msg[i++],posX,calcXWidth(spalte++));	
			}
			
			while (col++ < (DISPLAY_WIDTH))
			{
				glcdPutc(' ',posX,calcXWidth(spalte++));	
			}
		}
	}
}

char *glcdBuildPassword(uint8_t *pswd, uint8_t *b)
{
	b[0] = '|';
	b[1] = pswd[0];
	b[2] = '|';
	
	b[3] = '|';
	b[4] = pswd[1];
	b[5] = '|';
	
	b[6] = '|';
	b[7] = pswd[2];
	b[8] = '|';
	
	b[9] = '|';
	b[10] = pswd[3];
	b[11] = '|';
	
	b[12] = '\0';
	
	return (char*)b;
}




typedef struct
{
	const char	*Name;
	uint8_t		(*fp)			(void);
	uint8_t		cursPos;
}menue_t;


uint8_t showMenue(menue_t *m, enc_t *enc, size_t menueLen);
uint8_t menueDrawSubmenue(char *head, char *footer, uint8_t yhead, uint8_t yfooter);
uint8_t menuePassword( void );

uint8_t menueTime( void );
uint8_t menueDate( void );

uint8_t menueBrightness( void );
uint8_t menueContrast( void );
uint8_t menueSerNr( void );
uint8_t menueRelais( void );
uint8_t menueHardwareInfo( void );
uint8_t menueRestart( void );

uint8_t menueMACAdressen( void );
uint8_t menueBluetoothState( void );
uint8_t menueShowTransfer( void );
uint8_t menueTemp( void );
uint8_t menueAutoDimm( void );

uint8_t callSubMenueBrightness( void );
uint8_t callMainMenue( void );
uint8_t callSubMenueYesNo( void );
uint8_t callSubMenueBluetooth( void );
uint8_t callSubMenueAdminMode( void );

menue_t menueStructMain[]=
{
	/*
	*	Aktueller			Funktion hinter				Cursorposition
	*	Menüpunkt			dem aktuellen				nach dem verlassen
	*						Menüpunkt					der Funktion
	*
	*	Menüpunkt '0' wird nur für den Namen des Menüs verwendet!
	*/
	{"Einstellungen"	,	 NULL						,	0	},
	{"Uhrzeit"			,	menueTime					,	1	},
	{"Datum"			,	menueDate					,	2	},
	{"Temperatur"		,	menueTemp					,	3	},
	{"Helligkeit"		,	callSubMenueBrightness		,	4	},
	{"Kontrast"			,	menueContrast				,	5	},
	{"Seriennummer"		,	menueSerNr					,	6	},
	{"Admin"			,	callSubMenueAdminMode		,	7	},
	{"Bluetooth"		,	callSubMenueBluetooth		,	8	},
	{"Hardware Info"	,	menueHardwareInfo			,	9	},
	{"Neustart"			,	menueRestart				,	10	},
	{"Verlassen"		,	NULL						,	11	},
};

menue_t menueStructBluetooth[]=
{
	/*
	*	Aktueller			Funktion hinter				Cursorposition
	*	Menüpunkt			dem aktuellen				nach dem verlassen
	*						Menüpunkt					der Funktion
	*
	*	Menüpunkt '0' wird nur für den Namen des Menüs verwendet!
	*/
	{"Bluetooth"		,	NULL						,	0	},
	{"MAC Adressen"		,	menueMACAdressen			,	1	},
	{"Status"			,	menueBluetoothState			,	2	},
	{"Transfer"			,	menueShowTransfer			,	3	},
	{"Verlassen"		,	NULL						,	4	},
};

menue_t menueStructBrightness[]=
{
	/*
	*	Aktueller			Funktion hinter				Cursorposition
	*	Menüpunkt			dem aktuellen				nach dem verlassen
	*						Menüpunkt					der Funktion
	*
	*	Menüpunkt '0' wird nur für den Namen des Menüs verwendet!
	*/
	{"-Helligkeit"		,	NULL						,	0	},
	{"Helligkeit"		,	menueBrightness				,	1	},
	{"Auto. Dimm"		,	menueAutoDimm				,	2	},
	{"Verlassen"		,	NULL						,	3	},
};

menue_t menueStructAdminModes[]=
{
	{"Admin Mode"	,	NULL			,	0	},
	{"Relais"		,	menueRelais		,	1	},
	{"Reset"		,	NULL			,	2	},
};

menue_t menueStructChooseYesNo[]=
{
	#define YES_WAS_CLICKED		1
	#define NO_WAS_CLICKED		2
	#define CANCEL_WAS_CLICKED	3
	
	/*
	*	Aktueller			Funktion hinter				Cursorposition
	*	Menüpunkt			dem aktuellen				nach dem verlassen
	*						Menüpunkt					der Funktion
	*
	*	Menüpunkt '0' wird nur für den Namen des Menüs verwendet!
	*/
	{"-Speichern?	"	,	NULL						,	0	},
	{"Ja"				,	NULL						,	1	},
	{"Nein"				,	NULL						,	2	},
	{"Verlassen"		,	NULL						,	3	},
};


uint8_t showMenue(menue_t *m, enc_t *enc, size_t menueLen)
{
	glcdSetFont( Arial_14 );
	
	int8_t  pageStart = 0;
	uint8_t menueEntry = 0, y = 0, retCursor = 0;
	
	if ( enc->result <= 1 )
	{
		enc->result = 1;
	}
	else if ( enc->result > ( menueLen - 1 ) )
	{
		enc->result = (menueLen-1);
	}

	pageStart = enc->result - 3;
	
	if ( ( pageStart + 5 ) >= menueLen )
	{
		pageStart = menueLen - 5;
	}
	
	if ( pageStart < 0 )
	{
		pageStart = 0;
	}
	
	
	/*
	*	Menü Name
	*/
	glcdPuts((char*)m[0].Name,GLCD_CALC_PAGE(0),0);
	glcdDrawLine(53,0,128);
	
	
	for ( y = 2 ; y < 6 ; y++ )
	{	
		glcdSetPageColumn( 7 - y , 0 );
		for (uint8_t i = 0 ; i < 131 ; i++)
		{
			glcdSendData( 0x00 );
		}
		
		menueEntry = pageStart + (y-1);
		
		if (menueEntry < menueLen)
		{
			if (menueEntry == enc->result)
			{
				retCursor = enc->result;
				glcdPuts("->",GLCD_CALC_PAGE(y),0);
				glcdPuts((char*)m[menueEntry].Name,GLCD_CALC_PAGE(y),calcXWidth(2));
			}else
			glcdPuts((char*)m[menueEntry].Name,GLCD_CALC_PAGE(y),0);	
		}
	}
	
	glcdDrawLine( 10 , 0 , 128 );
	glcdPuts( (char*)board.id[ID_PROJECT] , GLCD_CALC_PAGE(7) , 0 );
	
	if ( ! ( ENC_SWITCH_PORT & 1 << ENC_SWITCH_bp ) )
	{	
		
		while (  ! ( ENC_SWITCH_PORT & 1 << ENC_SWITCH_bp ) );
				
		glcdClear();
		
		_delay_ms(50);
									
		/*
		*	Funktion aufrufen die für diesen Menüpunkt
		*	hinterlegt ist.
		*/			
		if ( m[retCursor].fp != NULL)
		{
			enc->result = 0 ;
			m[retCursor].fp();
		}			
				
		glcdClear();

		enc->result = m[retCursor].cursPos;				
				
		return retCursor;			
	}	

	return 0;
}


uint8_t callSubMenueBrightness( void )
{
	uint8_t result = 0;
	while( ( ! ( result ) ) )
	{
		result = showMenue( menueStructBrightness , (enc_t*)&encoder , ARRAY_SIZE(menueStructBrightness) );
	}
	
	return result;
}

uint8_t callMainMenue( void )
{
	uint8_t result = 0;
	while ( ( ! ( result ) ) )
	{
		result = showMenue( menueStructMain , (enc_t*)&encoder , ARRAY_SIZE(menueStructMain) );
	}
	return result;
}

uint8_t callSubMenueYesNo( void )
{
	uint8_t result = 0;
	
	/*
	*	Cursor default Position
	*/
	encoder.result = 0;
	
	while( ( ! ( result ) ) )
	{
		result = showMenue( menueStructChooseYesNo , (enc_t*)&encoder , ARRAY_SIZE(menueStructChooseYesNo) );
	}
	return result;
}

uint8_t callSubMenueBluetooth( void )
{
	uint8_t result = 0;
	while( ( ! ( result ) ) )
	{
		result = showMenue( menueStructBluetooth , (enc_t*)&encoder , ARRAY_SIZE(menueStructBluetooth) );
	}	
	return result;
}

void eepSetDefault(eep_t *e);

uint8_t callSubMenueAdminMode( void )
{
	uint8_t result = 0;
	
	if ( menuePassword() )
	{
		return 1;
	}
	
	encoder.result = 0;
	while( ( ! ( result ) ) )
	{
		result = showMenue( menueStructAdminModes , (enc_t*)&encoder , ARRAY_SIZE(menueStructAdminModes) );
	}
	
	switch( result )
	{
		case 1:
		{
			menueRelais();
		}break;
		
		case 2:
		{
			eepSetDefault( &eep );
			restart();
		}break;
	}
	
	return result;
}


uint8_t menueDrawSubmenue(char *head, char *footer, uint8_t yhead, uint8_t yfooter)
{
	glcdClear();

	if (!(head==NULL))
	{
		glcdPuts(head,GLCD_CALC_PAGE(0),yhead);
		glcdDrawLine(54,0,128);
	}
	
	if (!(footer==NULL))
	{
		glcdDrawLine(10,0,128);
		glcdPuts(footer,GLCD_CALC_PAGE(7),yfooter);
	}
	
	return 0;
}

uint8_t menuePassword( void )
{
	uint8_t pswdEntry [5] = "****";

	menueDrawSubmenue((char*)board.id[ID_MENUE_PASSWORD],(char*)board.id[ID_MENUE_ENTER_EXIT],0,0);

	if (((GGF() & (1<<ADMIN_LOGGED_IN)) == (1<<ADMIN_LOGGED_IN)))
	{
		glcdPuts((char*)board.id[ID_MENUE_ADMIN_LOGGED_IN],GLCD_CALC_PAGE(3),0);
		_delay_ms(1500);
		return 0;
	}
	
	for (uint8_t x = 0 ; x < 4 ; x++)
	{
		encoder.result = 0;
		while (1)
		{
			pswdEntry[x] = board.id[ID_MENUE_PASSWORD_CHARS][encoder.result];
			encoder.result = checkMaxValue(encoder.result , strlen(board.id[ID_MENUE_PASSWORD_CHARS]));
			
			glcdPuts(glcdBuildPassword(pswdEntry,buffer),GLCD_CALC_PAGE(3), 25 );
			
			if( ! ( ENC_SWITCH_PORT & 1<<ENC_SWITCH_bp ) )
			{
				_delay_ms(25);
				while ( ! ( ENC_SWITCH_PORT & 1<<ENC_SWITCH_bp ) );
				break;
			}
		}
		sys.adminPswd[x] = pswdEntry[x]; // Passwort sichern
		pswdEntry[x] = '*';
	}
	
	uint8_t checkPswd = 0;
	for ( uint8_t x = 0 ; x < 4 ; x++ )
	{
		if ( ( sys.adminPswd[x] == ADMIN_PSWD[x] ) )
		checkPswd++;
	}
	
	glcdPuts((char*)board.id[ID_MENUE_FREE_ROW],GLCD_CALC_PAGE(3),0);
	
	if ( checkPswd == 4 )
	{
		SGF(ADMIN_LOGGED_IN);
		return 0;
	}
	else
	{
		CGF(ADMIN_LOGGED_IN);
		glcdPuts( (char*)board.id[ID_PSWD_WRONG] , GLCD_CALC_PAGE(3) , 0 );
		sys.state.state.pswdErr = 1;	
		_delay_ms(750);
	}	
	
	return 1;
}

uint8_t menueAutoDimm( void )
{
	uint8_t result = callSubMenueYesNo();
	
	if ( result == YES_WAS_CLICKED )
	{
		sys.autoDimmEnable = 1;
		eeprom_update_byte( &eep.autoDimmEnable , 1 );
	}
	else if ( result == NO_WAS_CLICKED )
	{
		sys.autoDimmEnable = 0;
		eeprom_update_byte( &eep.autoDimmEnable , 0 );
	}	
	
	return 0;
}

uint8_t menueDate( void )
{
	menueDrawSubmenue((char*)board.id[ID_MENUE_SYS_DATE],(char*)board.id[ID_MENUE_ENTER_EXIT],0,0);
	
	setDate(buffer);
	
	uint8_t result = callSubMenueYesNo();
	if ( result == YES_WAS_CLICKED)
	{
		rtcSetDate(buffer[0],(buffer[3]+1),buffer[1],2000+buffer[2]);
	}

	return 0;
}

uint8_t menueTime( void )
{
	menueDrawSubmenue((char*)board.id[ID_MENUE_SYS_TIME],(char*)board.id[ID_MENUE_ENTER_EXIT],0,0);
	
	setTime(buffer);
	
	uint8_t result = callSubMenueYesNo();
	
	if ( result == YES_WAS_CLICKED )
	{
		rtcSetTime( buffer[0] , buffer[1] , buffer[2] );
	}
	
	return 0;
}


uint8_t menueBrightness( void )
{	
	menueDrawSubmenue((char*)board.id[ID_MENUE_BRIGHTNESS],(char*)board.id[ID_MENUE_ENTER_EXIT],0,0);

	encoder.result = eeprom_read_byte(&eep.brightness);
	
	glcdSetFont(fixednums8x16);
	
	uint8_t default_ = encoder.result;
	uint8_t brightness = 0;
	
	while (1)
	{
		encoder.result = checkMinValue( encoder.result , 0 );
		encoder.result = checkMaxValue( encoder.result , 100 );
		brightness = encoder.result;
		
		GLCD_SET_BRIGHTNESS(encoder.result);

		valToStr((char*)buffer,(uint16_t)encoder.result);
		removeLeadingNumbs( (char*)buffer , '0' );
		
		/*
		*	'*' = Leerzeichen! Aufgrund der Struktur im Zeichensatz
		*/
		strcat( (char*)buffer,"*");
		
		glcdPuts( (char*)buffer , GLCD_CALC_PAGE(3) , calcXWidth(7) );
		
		if(!(ENC_SWITCH_PORT & 1<<ENC_SWITCH_bp))
		{
			_delay_ms(25);
			while ( ! ( ENC_SWITCH_PORT & 1<<ENC_SWITCH_bp ) );
			break;
		}
	}

	uint8_t result = callSubMenueYesNo();
	
	if (result == YES_WAS_CLICKED )
	{
		eeprom_update_byte( &eep.brightness, brightness );
	}
	else if (result == NO_WAS_CLICKED )
	{
		GLCD_SET_BRIGHTNESS( default_ );
	}
	
	return 0;
}

uint8_t menueContrast( void )
{
	menueDrawSubmenue((char*)board.id[ID_MENUE_CONTRAST],(char*)board.id[ID_MENUE_ENTER_EXIT],0,0);

	encoder.result = eeprom_read_byte(&eep.contrast);
	uint8_t default_ = (uint8_t)encoder.result;
	uint8_t contrast = 0;

	glcdSetFont(fixednums8x16);

	
	while (1)
	{
		encoder.result = checkMinValue( encoder.result , 35 );
		encoder.result = checkMaxValue( encoder.result , 48 );
		contrast = encoder.result;
		
		valToStr((char*)buffer,(uint16_t)encoder.result);
		removeLeadingNumbs((char*)buffer,'0');
		
		glcdPuts((char*)buffer,GLCD_CALC_PAGE(3),calcXWidth(7));
		
		glcdSendCmd(CMD_SET_VOLUME_FIRST);
		glcdSendCmd(encoder.result);
		
		if(!(ENC_SWITCH_PORT & 1<<ENC_SWITCH_bp))
		{
			_delay_ms(25);
			while ( ! ( ENC_SWITCH_PORT & 1<<ENC_SWITCH_bp ) );
			break;
		}
	}
	
	uint8_t result = callSubMenueYesNo();
	if ( result == YES_WAS_CLICKED )
	{
		eeprom_update_byte( &eep.contrast , contrast );
	}
	else if( result == NO_WAS_CLICKED )
	{
		glcdSendCmd( CMD_SET_VOLUME_FIRST );
		glcdSendCmd( default_ );
	}
	
	return 0;
}

uint8_t menueSerNr( void )
{
	menueDrawSubmenue((char*)board.id[ID_MENUE_SERNR],(char*)board.id[ID_MENUE_ENTER_EXIT],0,0);
	
	glcdSetFont(fixednums8x16);
	
	glcdPuts( eepRAM.srn , GLCD_CALC_PAGE(3) ,calcXWidth(4) );

	while(1)
	{
		if(!(ENC_SWITCH_PORT & 1<<ENC_SWITCH_bp))
		{
			_delay_ms(25);
			while ( ! ( ENC_SWITCH_PORT & 1<<ENC_SWITCH_bp ) );
			break;
		}
	}
	
	return 0;
}

uint8_t menueRelais( void )
{	
	if (!((GGF()&1<<ADMIN_LOGGED_IN)==1<<ADMIN_LOGGED_IN))
	{
		menuePassword();
	}
	if (!((GGF()&1<<ADMIN_LOGGED_IN)==1<<ADMIN_LOGGED_IN))return 0;
	
	menueDrawSubmenue((char*)board.id[ID_MENUE_RELAIS],(char*)board.id[ID_MENUE_ENTER_EXIT],0,0);
			
	uint8_t relais;
	
	encoder.result = activeRelais;
	
	while (1)
	{
		relais = encoder.result;
	
		encoder.result = checkMinValue( encoder.result , 0 );
		encoder.result = checkMaxValue( encoder.result , 255 );	
		
		valToStr((char*)buffer,relais);
		removeLeadingNumbs((char*)buffer,'0');
		
		
		glcdPuts((char*)board.id[ID_MENUE_ACTIVE_RELAIS],GLCD_CALC_PAGE(2),0);
		
		/*
		*	Leerzeichen ausgeben damit die letzten Zeichen überschrieben werden
		*	und nicht stehen bleiben
		*/
		strcat( (char*)buffer,"  ");
		
		glcdPuts((char*)buffer,GLCD_CALC_PAGE(2),calcXWidth(18));
		
		setRelais(relais);
		
		memset(buffer,0,sizeof(buffer));
		uint8_t x = 0;
		for (	; x < 4 ; x++ )
		{
			if ((relais & 1<<0) == 1<<0)
			{
				strcat((char*)buffer,board.id[ID_MENUE_RELAIS_NAME_1+x]);
			}
			else
			{
				strcat((char*)buffer,"|-|");
			}
			
			relais>>=1;
		}
		glcdPuts((char*)buffer,GLCD_CALC_PAGE(4),calcXWidth(4));
		
		memset(buffer,0,sizeof(buffer));

		for (	; x < 8 ; x++)
		{
			if ((relais & 1<<0) == 1<<0)
			{
				strcat((char*)buffer,board.id[ID_MENUE_RELAIS_NAME_1+x]);
			}
			else
			{
				strcat((char*)buffer,"|-|");
			}
			
			relais>>=1;
		}
		glcdPuts((char*)buffer,GLCD_CALC_PAGE(5),calcXWidth(4));		
		
		if(!(ENC_SWITCH_PORT & 1<<ENC_SWITCH_bp))
		{
			_delay_ms(25);
			while ( ! ( ENC_SWITCH_PORT & 1<<ENC_SWITCH_bp ) );
			break;
		}
	}
	
	CGF(ADMIN_LOGGED_IN);
	encoder.result = 0;	
	
	return 0;
}

uint8_t menueHardwareInfo( void )
{
	menueDrawSubmenue(NULL,(char*)board.id[ID_MENUE_ENTER_EXIT],0,0);
	
	glcdSetPageColumn(7,0);
	glcdPrintInfo(eepRAM.srn);
	
	while(1)
	{
		if(!(ENC_SWITCH_PORT & 1<<ENC_SWITCH_bp))
		{
			_delay_ms(25);
			while ( ! ( ENC_SWITCH_PORT & 1<<ENC_SWITCH_bp ) );
			break;
		}
	}
	
	return 0;
}

uint8_t menueRestart( void )
{	
	uint8_t result = callSubMenueYesNo();
	
	if ( result == YES_WAS_CLICKED )
	{
		glcdClear();
		glcdPuts((char*)board.id[ID_MENUE_RESTART_APP],GLCD_CALC_PAGE(3),0);
		_delay_ms(800);

		restart();		
	}

	return 0;
}

uint8_t menueMACAdressen( void )
{
	menueDrawSubmenue((char*)board.id[ID_MENUE_MAC_ADDR],"BETA",0,0);
	

	glcdPuts((char*)board.id[ID_MENUE_MASTER],GLCD_CALC_PAGE(2),0);
	glcdPuts((char*)board.id[ID_MENUE_NOT_CONNECTED],GLCD_CALC_PAGE(3),0);

	glcdPuts((char*)board.id[ID_MENUE_SLAVE],GLCD_CALC_PAGE(4),0);
	glcdPuts((char*)board.id[ID_MENUE_NOT_CONNECTED],GLCD_CALC_PAGE(5),0);
	
	while(1)
	{
		if(!(ENC_SWITCH_PORT & 1<<ENC_SWITCH_bp))
		{
			_delay_ms(25);
			while ( ! ( ENC_SWITCH_PORT & 1<<ENC_SWITCH_bp ) );
			break;
		}
	}
	
	return 0;
}

uint8_t menueBluetoothState( void )
{
	menueDrawSubmenue((char*)board.id[ID_MENUE_BLTH_STATE],"BETA",0,0);
	
	glcdPuts((char*)board.id[ID_MENUE_NOT_CONNECTED],GLCD_CALC_PAGE(3),0);
	
	while(1)
	{
		if(!(ENC_SWITCH_PORT & 1<<ENC_SWITCH_bp))
		{
			_delay_ms(25);
			while ( ! ( ENC_SWITCH_PORT & 1<<ENC_SWITCH_bp ) );
			break;
		}
	}
	
	return 0;
}

uint8_t menueShowTransfer( void )
{
	menueDrawSubmenue("Transfer (Rx/Tx)",(char*)board.id[ID_MENUE_ENTER_EXIT],0,0);
		
	while (1)
	{	
		strcpy((char*)buffer,"CRC Err.:");
		valToStr((char*)&buffer[9],crc.err);
		removeLeadingNumbs((char*)&buffer[9],'0');
		glcdPuts((char*)buffer,GLCD_CALC_PAGE(2),0);

		strcpy((char*)buffer,"Tx.:");
		valToStr((char*)&buffer[4],uart.txCnt);
		removeLeadingNumbs((char*)&buffer[4],'0');
		glcdPuts((char*)buffer,GLCD_CALC_PAGE(4),0);
		
		strcpy((char*)buffer,"Rx.:");
		valToStr((char*)&buffer[4],uart.rxCnt);	
		removeLeadingNumbs((char*)&buffer[4],'0');
		glcdPuts((char*)buffer,GLCD_CALC_PAGE(5),0);
	
		/*
		*	Verarbeite Kommandos von der Seriellen Schnittstelle
		*/
		uartProcess(&uart);

		if(!(ENC_SWITCH_PORT & 1<<ENC_SWITCH_bp))
		{
			_delay_ms(25);
			while ( ! ( ENC_SWITCH_PORT & 1<<ENC_SWITCH_bp ) );
			break;
		}
	}
	
	return 0;
}

uint8_t menueTemp( void )
{
	menueDrawSubmenue( (char*)board.id[ID_MENUE_TEMPERATURE] , (char*)board.id[ID_MENUE_ENTER_EXIT], 0 , 0 );
	
	char tempStr[4] = "";
	uint32_t show = 0;
	uint8_t state = 0, stateOld = 0;

	while(1)
	{	
		refreshTemp();
		
		if (stateOld != state)
		{
			stateOld = state;
			glcdClearLine(2,0,16);
			glcdClearLine(4,0,16);
		}
		
		if ( show++ < 100)
		{
			state = 0x00;
			glcdSetFont(Arial_14);
			glcdPuts( "Low.   Act.    Hig.  " , GLCD_CALC_PAGE(2) , calcXWidth(0) );
		
			glcdSetFont(fixednums8x16);
		
		
			/*
			*	Niedrigst gemessene Temperatur
			*/
			glcdClearLine( 4 , 0 , 4);
			glcdPuts( itoa( sts3x.lowest   , (char*)tempStr, 10 ) , GLCD_CALC_PAGE(4) , calcXWidth(0) );		
		
			/*
			*	Aktuell gemessene Temperatur
			*/
			glcdClearLine( 4 , 6 , 4);
			glcdPuts( itoa( sts3x.actual   , (char*)tempStr, 10 ) , GLCD_CALC_PAGE(4) , calcXWidth(6) );
		
			/*
			*	Die höchst gemessene Temperatur
			*/
			glcdClearLine( 4 , 12 , 4);
			glcdPuts( itoa( sts3x.highest  , (char*)tempStr, 10 ) , GLCD_CALC_PAGE(4) , calcXWidth(12) );				
		}
		else if ( show > 100)
		{
			state = 0x01;
			glcdSetFont(Arial_14);
			glcdPuts ( "L:", GLCD_CALC_PAGE(2) , 0 );
			
			glcdSetFont(fixednums8x16);
			glcdPuts ( itoa( stamp[0].temp  , (char*)tempStr, 10 ) , GLCD_CALC_PAGE(2) , calcXWidth(2) );
			glcdPuts ( stamp[0].time , GLCD_CALC_PAGE(2) , calcXWidth(7) );

			glcdSetFont(Arial_14);
			glcdPuts ( "H:", GLCD_CALC_PAGE(4) , 0 );
			
			glcdSetFont(fixednums8x16);			
			glcdPuts ( itoa( stamp[1].temp  , (char*)tempStr, 10 ) , GLCD_CALC_PAGE(4) , calcXWidth(2) );
			glcdPuts ( stamp[1].time , GLCD_CALC_PAGE(4) , calcXWidth(7) );
		}
		show = checkMaxValue( show , 300 );
		
		
		if(!(ENC_SWITCH_PORT & 1<<ENC_SWITCH_bp))
		{
			_delay_ms(25);
			while (!(ENC_SWITCH_PORT & 1<<ENC_SWITCH_bp));
			break;
		}	
	}
	
	return 0;
}



void buildNewsticker(newsticker_t *news)
{
	strcpy(news->newsBuff,"+++Ver.: ");
	strcat(news->newsBuff,buildVer());
	strcat(news->newsBuff," | ");
	strcat(news->newsBuff,board.id[ID_MADE_BY]);
	strcat(news->newsBuff," | ");
	news->staticStrLeng = (strlen(news->newsBuff)-1);
}

void addNewstickerErrors(newsticker_t *news, uint16_t err)
{
	strcpy(&news->newsBuff[news->staticStrLeng]," Status.:");
	strcat(news->newsBuff,decHex16(err,(char*)buffer));
	strcat(news->newsBuff," |  ");
	
	news->errorStrLeng = (strlen(news->newsBuff)-1);
}

void addNewstickerTime(newsticker_t *news)
{
	rtcGetData(&rtc);
	strcpy(&news->newsBuff[news->errorStrLeng],bcd_ttostr(rtc.hour,rtc.minute,rtc.second));
	strcat(news->newsBuff," | ");
	strcat(news->newsBuff,bcd_dtostr(rtc.day,rtc.month,rtc.year+2000,rtc.dayName));
	strcat(news->newsBuff," | ");
	
	news->timeDateStrLeng = (strlen(news->newsBuff)-1);	
}

void addNewstickerStr(newsticker_t *news, char *str, uint8_t endof)
{
	strcpy(&news->newsBuff[strlen(news->newsBuff)],str);
	if (endof)
	strcat(news->newsBuff,"+++");
}

void eepSetDefault(eep_t *e)
{	
	eeprom_write_byte(&e->brightness, 50);
	waitEEPIsBusy();
	
	eeprom_write_byte(&e->contrast, 35);
	waitEEPIsBusy();
	
	eeprom_write_byte(&e->userNameLen , EEP_LENG_OF_USER_NAME);
	waitEEPIsBusy();
	
	eeprom_write_block((char*)"xxxxxxxxxxxxxxx",(char*)e->userName,EEP_LENG_OF_USER_NAME);
	waitEEPIsBusy();
	
	eeprom_write_block((char*)"xxxxxx",(char*)e->srn,EEP_LENG_OF_SERNR);
	waitEEPIsBusy();
	
	eeprom_write_word(&e->startUpDevice,0);
	waitEEPIsBusy();
	
	eeprom_write_byte( &e->autoDimmEnable , 1);
	
	eeprom_write_byte( &e->init , EEP_IS_INIT);
	waitEEPIsBusy();
}

void loadEEP(eep_t *eep, eep_t *ram)
{
	cli();
	
	ram->init = eeprom_read_byte(&eep->init);
	if ( ram->init != 0x3C )
	{
		eepSetDefault(eep);
		loadEEP(eep,ram);
	}
	else
	{
		ram->contrast		= eeprom_read_byte(&eep->contrast);	
		ram->brightness		= eeprom_read_byte(&eep->brightness);
		ram->userNameLen	= eeprom_read_byte(&eep->userNameLen);
	
		eeprom_read_block((char*)ram->srn,eep->srn,EEP_LENG_OF_SERNR);
		eeprom_read_block((char*)ram->userName,eep->userName,ram->userNameLen);	
		
		ram->startUpDevice = eeprom_read_word(&eep->startUpDevice);
		eeprom_write_word(&eep->startUpDevice,++ram->startUpDevice);	
		
		ram->autoDimmEnable = eeprom_read_byte( &eep->autoDimmEnable );
	}
	sei();
}

void uartWelcomeMsg(void)
{	
	for ( uint8_t i = 0 ; i < 3 ; i++ )
	{
		uart_puts(board.id[ID_PROJECT+i]);
		uart_puts("\r\n");
	}
	uart_puts(board.buildSwVer());
}

void DevBoardLock( void )
{
	SET_COLOR_RED
	glcdPrintImage( schloss , sizeof( schloss ) , 63 , 33 );	
}

void DevBoardUnlock( void )
{
	SET_COLOR_GREEN
	glcdPrintImage( key , sizeof( key ) , 55 , 10 );	
}

int main(void)
{				
	hardware_init();
	uart_init(UART_BAUD_SELECT(UART_BAUD_RATE,16e6));
	i2c_init();	
	rtcInit(); 
	rtcSetClkOut(F_1Hz);
 	timerInit();	
	sts3x_init();
	sei();

	
	/*
	*	EEPROM Daten laden..
	*/
	loadEEP(&eep,&eepRAM);
	
	/*
	*	GLCD Initalisieren mit vorher konfigurierem Kontrast
	*/
	glcdInit(eepRAM.contrast);
	
	/*
	*	Systemschrift setzen
	*/
	glcdSetFont(System5x7);
	
	/*
	*	Überprüfen ob das Gerät eine Seriennummer hat,
	*	sollte dies nicht der Fall sein, kann man die Software nicht benutzen
	*/
	char *serialNr = checkSerialNumber(eepRAM.srn, &sys);
	if (serialNr != NULL)
	{
		glcdPrintInfo(serialNr);
	}
	else
	{
		glcdPrintInfo((char*)board.id[ID_ERR]);
	}
	_delay_ms(1000);
		
	/*
	*	Festen Text für den Newsticker schreiben.
	*	Dies muss nur einmal vor dem Start geschehen
	*/
	buildNewsticker(&newsticker);
		
	glcdClear();

	/*
	*	Ab hier kann die Software dann nicht mehr genutzt werden, sollte
	*	keine Seriennummer vorhanden sein oder das Gerät wurde mehr als 
	*	LOCK_SOFTWARE_AFTER_X_TURN_ON gestartet
	*/
// 	uint8_t adminUnlock = 1;
// 	if ( sys.state.state.SerNrErr || eepRAM.startUpDevice >= LOCK_SOFTWARE_AFTER_X_TURN_ON )
// 	{
// 		DevBoardLock();
// 		while ( adminUnlock )
// 		{
// 			if ( ( ! ( ENC_SWITCH_PORT & 1 << ENC_SWITCH_bp ) ) )
// 			{
// 				_delay_ms(25);
// 				while ( ( ! (ENC_SWITCH_PORT & 1 << ENC_SWITCH_bp ) ) );
// 				
// 				adminUnlock = menuePassword();
// 				glcdClear();
// 				DevBoardLock();
// 			}
// 			
// 			uartProcess( &uart );
// 		}		
// 	}
// 	else
// 	{
// 		DevBoardUnlock();
// 		_delay_ms(1500);	
// 	}
	
	/*
	*	Zu letzt gespeicherte Helligkeit laden und benutzen
	*/
	GLCD_SET_BRIGHTNESS(eepRAM.brightness);
	
	/*
	*	Softwareinformationen Seriell ausgeben
	*/
	uartWelcomeMsg();
	
	glcdClear();
	
// 	sys.autoDimmEnable = eepRAM.autoDimmEnable;
// 	
// 	uint8_t menueExit = 0;
// 	while( menueExit != 12 )
// 	{
// 		menueExit = showMenue( menueStructMain , (enc_t*)&encoder, ARRAY_SIZE(menueStructMain) );
// 	};
	
	while (1) 
    {			
// 		/*
// 		*	Lauftext.: Newsticker.
// 		*/
// 		if (sys.scrollTime > 5000)
// 		{
// 			sys.scrollTime = 0;
// 	
// 			glcdDrawLine(10,0,127);	
// 			addNewstickerErrors(&newsticker,sys.state.result);
// 			addNewstickerTime(&newsticker);
// 			addNewstickerStr(&newsticker,"User.: ",0);
// 			addNewstickerStr(&newsticker,(char*)eepRAM.userName,1);	
// 						
// 			glcdScrollMsg(7,newsticker.newsBuff);
// 		}
// 		
// 		refreshTemp();
		
		/*
		*	Verarbeite Kommandos von der Seriellen Schnittstelle
		*/
		uartProcess(&uart);		
    }
}

/* live the CPU?*/
ISR(TIMER1_COMPA_vect)
{
	static uint32_t stateLED = 0;
	
	sts3xRead++;
	sys.scrollTime++;
	sys.autoDimm++;
	
	/*
	*	Status Anzeige
	*/
	stateLED = checkMaxValue( ++stateLED , 10e3 );
	
	if ( stateLED <= 200 )
	{
		BC(LED_HEARTBEAT_PORT,LED_HEARTBEAT_bp);
	}
	else if ( ( stateLED >= 400 ) && ( stateLED <= 600 ) )
	{
		BS(LED_HEARTBEAT_PORT,LED_HEARTBEAT_bp);
	}
	else if ( ( stateLED >= 1000 ) && ( stateLED <= 1400 ) )
	{
		BC(LED_HEARTBEAT_PORT,LED_HEARTBEAT_bp);
	}
	else if ( ( stateLED >= 1600 ) && ( stateLED <= 1800 ) )
	{
		BS(LED_HEARTBEAT_PORT,LED_HEARTBEAT_bp);
	}
	
	/*
	*	Drehencoder auswertung.
	*/
	encoder.Last = ( ( encoder.Last << 2 ) & 0x0F );
	if (ENC_PIN & 1<<ENC_B)
	{
		encoder.Last |= 2;
	}
	if (ENC_PIN & 1<<ENC_A)
	{
		encoder.Last |= 1;
	} 	
	encoder.result += encoder.Table[encoder.Last];		
		
	/*
	*	Software PWM
	*/	
	static uint8_t pwmCnt = 0;
	
	if ( pwmCnt >= PWM_FREQUENZ )
	{
		pwmCnt = 0;
	}
	else
	{
		pwmCnt++;
	}
	
	if ( pwmCnt >= pwm.glcd.red )
	BC(GLCD_LED_PORT,GLCD_LED_RED_bp);
	else
	BS(GLCD_LED_PORT,GLCD_LED_RED_bp);

	if ( pwmCnt >= pwm.glcd.green )
	BC(GLCD_LED_PORT,GLCD_LED_GREEN_bp);
	else
	BS(GLCD_LED_PORT,GLCD_LED_GREEN_bp);
	
	if ( pwmCnt >= pwm.glcd.blue )
	BC(GLCD_LED_PORT,GLCD_LED_BLUE_bp);
	else
	BS(GLCD_LED_PORT,GLCD_LED_BLUE_bp);

	static int8_t lastResult = 0;
	if ( lastResult != encoder.result )
	{
		lastResult = encoder.result;
		sys.autoDimm = 0;
		pwm.fadeUp = 1;
	}

	if( ( sys.autoDimm > 10e5 ) && ( sys.autoDimmEnable ) )
	{
		pwm.fadeUp = 0;
	}
	
	if ( ( sys.autoDimmDelay++ > 200 && sys.autoDimmEnable ) )
	{
		if ( pwm.fadeUp ) // Hoch faden
		{
			if ( pwm.glcd.red < eepRAM.brightness )
			{	
				pwm.glcd.red++;
				pwm.glcd.green++;
				pwm.glcd.blue++;					
			}
		}
		else
		{
			if ( pwm.glcd.red > DISP_MIN_PWM ) // Runter faden
			{	
				pwm.glcd.red--;
				pwm.glcd.green--;
				pwm.glcd.blue--;
			}
			else
			{
				pwm.fadeUp = 0;
			}		
		}
		sys.autoDimmDelay = 0;
	}
}