
RelaisSwitchBox.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000ad0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000001d2  00800060  00000ad0  00000b64  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000001af  00800232  00800232  00000d36  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000d36  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000d68  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000148  00000000  00000000  00000da4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001971  00000000  00000000  00000eec  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000b30  00000000  00000000  0000285d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000d20  00000000  00000000  0000338d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000394  00000000  00000000  000040b0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000006f3  00000000  00000000  00004444  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001253  00000000  00000000  00004b37  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000110  00000000  00000000  00005d8a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 9f 04 	jmp	0x93e	; 0x93e <__vector_7>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 84 02 	jmp	0x508	; 0x508 <__vector_13>
  38:	0c 94 b0 02 	jmp	0x560	; 0x560 <__vector_14>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	12 e0       	ldi	r17, 0x02	; 2
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e0 ed       	ldi	r30, 0xD0	; 208
  68:	fa e0       	ldi	r31, 0x0A	; 10
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a2 33       	cpi	r26, 0x32	; 50
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	23 e0       	ldi	r18, 0x03	; 3
  78:	a2 e3       	ldi	r26, 0x32	; 50
  7a:	b2 e0       	ldi	r27, 0x02	; 2
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a1 3e       	cpi	r26, 0xE1	; 225
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 36 04 	call	0x86c	; 0x86c <main>
  8a:	0c 94 66 05 	jmp	0xacc	; 0xacc <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <buildVer>:
	static char build[] = "00000000000000000";
	
	/*
	*	major and minor version
	*/
	build[0] = verMajor;
  92:	e0 e6       	ldi	r30, 0x60	; 96
  94:	f0 e0       	ldi	r31, 0x00	; 0
  96:	81 e3       	ldi	r24, 0x31	; 49
  98:	80 83       	st	Z, r24
	build[1] = '.';
  9a:	2e e2       	ldi	r18, 0x2E	; 46
  9c:	21 83       	std	Z+1, r18	; 0x01
	build[2] = ' ';
  9e:	90 e2       	ldi	r25, 0x20	; 32
  a0:	92 83       	std	Z+2, r25	; 0x02
	build[3] = verMinor;
  a2:	30 e3       	ldi	r19, 0x30	; 48
  a4:	33 83       	std	Z+3, r19	; 0x03
	build[4] = '.';
  a6:	24 83       	std	Z+4, r18	; 0x04
	build[5] = ' ';
  a8:	95 83       	std	Z+5, r25	; 0x05
		
	/*
	*	time.: hour|min
	*/
	build[6] = __TIME__[0];
  aa:	86 83       	std	Z+6, r24	; 0x06
	build[7] = __TIME__[1];
  ac:	87 83       	std	Z+7, r24	; 0x07
	build[8] = __TIME__[3];
  ae:	84 e3       	ldi	r24, 0x34	; 52
  b0:	80 87       	std	Z+8, r24	; 0x08
	build[9] = __TIME__[4];
  b2:	88 e3       	ldi	r24, 0x38	; 56
  b4:	81 87       	std	Z+9, r24	; 0x09
	
	build[10] = '.';
  b6:	22 87       	std	Z+10, r18	; 0x0a
	build[11] = ' ';
  b8:	93 87       	std	Z+11, r25	; 0x0b
	
	/*
	*	day
	*/
	build[12] = ((__DATE__[4] >= '0') ? (__DATE__[4]) : '0');
  ba:	34 87       	std	Z+12, r19	; 0x0c
	build[13] = (__DATE__[ 5]);
  bc:	85 87       	std	Z+13, r24	; 0x0d
	
	if(__DATE__[0] == 'J' && __DATE__[1] == 'u' && __DATE__[2] == 'l')
	build[14] = '7'; // Juli
	
	if(__DATE__[0] == 'A' && __DATE__[1] == 'u')
	build[14] = '8'; // August
  be:	86 87       	std	Z+14, r24	; 0x0e
	if(__DATE__[0] == 'D'){
		build[14] = '1';
		build[15] = '2'; // Dezember
	}

	build[16] = '\0';
  c0:	10 8a       	std	Z+16, r1	; 0x10
	
	return build;
}
  c2:	cf 01       	movw	r24, r30
  c4:	08 95       	ret

000000c6 <cmdSearch>:
	{
		*outPtr++ = *crcPtr++;
	}	
	
	return out;	
}
  c6:	0f 93       	push	r16
  c8:	1f 93       	push	r17
  ca:	cf 93       	push	r28
  cc:	df 93       	push	r29
  ce:	00 97       	sbiw	r24, 0x00	; 0
  d0:	c1 f0       	breq	.+48     	; 0x102 <cmdSearch+0x3c>
  d2:	61 15       	cp	r22, r1
  d4:	71 05       	cpc	r23, r1
  d6:	c1 f0       	breq	.+48     	; 0x108 <cmdSearch+0x42>
  d8:	ec 01       	movw	r28, r24
  da:	0e 94 44 05 	call	0xa88	; 0xa88 <strstr>
  de:	8c 01       	movw	r16, r24
  e0:	6b e3       	ldi	r22, 0x3B	; 59
  e2:	70 e0       	ldi	r23, 0x00	; 0
  e4:	ce 01       	movw	r24, r28
  e6:	0e 94 39 05 	call	0xa72	; 0xa72 <strchr>
  ea:	89 2b       	or	r24, r25
  ec:	81 f0       	breq	.+32     	; 0x10e <cmdSearch+0x48>
  ee:	01 15       	cp	r16, r1
  f0:	11 05       	cpc	r17, r1
  f2:	81 f0       	breq	.+32     	; 0x114 <cmdSearch+0x4e>
  f4:	10 93 33 02 	sts	0x0233, r17	; 0x800233 <__data_end+0x1>
  f8:	00 93 32 02 	sts	0x0232, r16	; 0x800232 <__data_end>
  fc:	80 2f       	mov	r24, r16
  fe:	91 2f       	mov	r25, r17
 100:	0b c0       	rjmp	.+22     	; 0x118 <cmdSearch+0x52>
 102:	80 e0       	ldi	r24, 0x00	; 0
 104:	90 e0       	ldi	r25, 0x00	; 0
 106:	08 c0       	rjmp	.+16     	; 0x118 <cmdSearch+0x52>
 108:	80 e0       	ldi	r24, 0x00	; 0
 10a:	90 e0       	ldi	r25, 0x00	; 0
 10c:	05 c0       	rjmp	.+10     	; 0x118 <cmdSearch+0x52>
 10e:	80 e0       	ldi	r24, 0x00	; 0
 110:	90 e0       	ldi	r25, 0x00	; 0
 112:	02 c0       	rjmp	.+4      	; 0x118 <cmdSearch+0x52>
 114:	80 2f       	mov	r24, r16
 116:	91 2f       	mov	r25, r17
 118:	df 91       	pop	r29
 11a:	cf 91       	pop	r28
 11c:	1f 91       	pop	r17
 11e:	0f 91       	pop	r16
 120:	08 95       	ret

00000122 <cmdGetIndex>:
 122:	ef 92       	push	r14
 124:	ff 92       	push	r15
 126:	0f 93       	push	r16
 128:	1f 93       	push	r17
 12a:	cf 93       	push	r28
 12c:	df 93       	push	r29
 12e:	20 91 dd 03 	lds	r18, 0x03DD	; 0x8003dd <cmd+0x2>
 132:	30 91 de 03 	lds	r19, 0x03DE	; 0x8003de <cmd+0x3>
 136:	23 2b       	or	r18, r19
 138:	29 f1       	breq	.+74     	; 0x184 <cmdGetIndex+0x62>
 13a:	7c 01       	movw	r14, r24
 13c:	80 e0       	ldi	r24, 0x00	; 0
 13e:	90 e0       	ldi	r25, 0x00	; 0
 140:	c0 e0       	ldi	r28, 0x00	; 0
 142:	0b ed       	ldi	r16, 0xDB	; 219
 144:	13 e0       	ldi	r17, 0x03	; 3
 146:	d7 e2       	ldi	r29, 0x27	; 39
 148:	d8 9f       	mul	r29, r24
 14a:	90 01       	movw	r18, r0
 14c:	d9 9f       	mul	r29, r25
 14e:	30 0d       	add	r19, r0
 150:	11 24       	eor	r1, r1
 152:	f8 01       	movw	r30, r16
 154:	60 81       	ld	r22, Z
 156:	71 81       	ldd	r23, Z+1	; 0x01
 158:	62 0f       	add	r22, r18
 15a:	73 1f       	adc	r23, r19
 15c:	6c 5e       	subi	r22, 0xEC	; 236
 15e:	7f 4f       	sbci	r23, 0xFF	; 255
 160:	c7 01       	movw	r24, r14
 162:	0e 94 63 00 	call	0xc6	; 0xc6 <cmdSearch>
 166:	89 2b       	or	r24, r25
 168:	11 f0       	breq	.+4      	; 0x16e <cmdGetIndex+0x4c>
 16a:	8c 2f       	mov	r24, r28
 16c:	0c c0       	rjmp	.+24     	; 0x186 <cmdGetIndex+0x64>
 16e:	cf 5f       	subi	r28, 0xFF	; 255
 170:	8c 2f       	mov	r24, r28
 172:	90 e0       	ldi	r25, 0x00	; 0
 174:	f8 01       	movw	r30, r16
 176:	22 81       	ldd	r18, Z+2	; 0x02
 178:	33 81       	ldd	r19, Z+3	; 0x03
 17a:	82 17       	cp	r24, r18
 17c:	93 07       	cpc	r25, r19
 17e:	20 f3       	brcs	.-56     	; 0x148 <cmdGetIndex+0x26>
 180:	8f ef       	ldi	r24, 0xFF	; 255
 182:	01 c0       	rjmp	.+2      	; 0x186 <cmdGetIndex+0x64>
 184:	8f ef       	ldi	r24, 0xFF	; 255
 186:	df 91       	pop	r29
 188:	cf 91       	pop	r28
 18a:	1f 91       	pop	r17
 18c:	0f 91       	pop	r16
 18e:	ff 90       	pop	r15
 190:	ef 90       	pop	r14
 192:	08 95       	ret

00000194 <cmdInit>:
 194:	eb ed       	ldi	r30, 0xDB	; 219
 196:	f3 e0       	ldi	r31, 0x03	; 3
 198:	91 83       	std	Z+1, r25	; 0x01
 19a:	80 83       	st	Z, r24
 19c:	53 83       	std	Z+3, r21	; 0x03
 19e:	42 83       	std	Z+2, r20	; 0x02
 1a0:	75 83       	std	Z+5, r23	; 0x05
 1a2:	64 83       	std	Z+4, r22	; 0x04
 1a4:	08 95       	ret

000001a6 <cmdGetName>:
 1a6:	0e 94 91 00 	call	0x122	; 0x122 <cmdGetIndex>
 1aa:	8f 3f       	cpi	r24, 0xFF	; 255
 1ac:	61 f0       	breq	.+24     	; 0x1c6 <cmdGetName+0x20>
 1ae:	20 91 db 03 	lds	r18, 0x03DB	; 0x8003db <cmd>
 1b2:	30 91 dc 03 	lds	r19, 0x03DC	; 0x8003dc <cmd+0x1>
 1b6:	a9 01       	movw	r20, r18
 1b8:	67 e2       	ldi	r22, 0x27	; 39
 1ba:	86 02       	muls	r24, r22
 1bc:	40 0d       	add	r20, r0
 1be:	51 1d       	adc	r21, r1
 1c0:	11 24       	eor	r1, r1
 1c2:	ca 01       	movw	r24, r20
 1c4:	08 95       	ret
 1c6:	80 e0       	ldi	r24, 0x00	; 0
 1c8:	90 e0       	ldi	r25, 0x00	; 0
 1ca:	08 95       	ret

000001cc <cmdGetFunc>:
 1cc:	0e 94 91 00 	call	0x122	; 0x122 <cmdGetIndex>
 1d0:	8f 3f       	cpi	r24, 0xFF	; 255
 1d2:	61 f0       	breq	.+24     	; 0x1ec <cmdGetFunc+0x20>
 1d4:	e0 91 db 03 	lds	r30, 0x03DB	; 0x8003db <cmd>
 1d8:	f0 91 dc 03 	lds	r31, 0x03DC	; 0x8003dc <cmd+0x1>
 1dc:	97 e2       	ldi	r25, 0x27	; 39
 1de:	89 02       	muls	r24, r25
 1e0:	e0 0d       	add	r30, r0
 1e2:	f1 1d       	adc	r31, r1
 1e4:	11 24       	eor	r1, r1
 1e6:	83 a1       	ldd	r24, Z+35	; 0x23
 1e8:	94 a1       	ldd	r25, Z+36	; 0x24
 1ea:	08 95       	ret
 1ec:	80 e0       	ldi	r24, 0x00	; 0
 1ee:	90 e0       	ldi	r25, 0x00	; 0
 1f0:	08 95       	ret

000001f2 <cmdGetPara>:
 1f2:	bf 92       	push	r11
 1f4:	cf 92       	push	r12
 1f6:	df 92       	push	r13
 1f8:	ef 92       	push	r14
 1fa:	ff 92       	push	r15
 1fc:	0f 93       	push	r16
 1fe:	1f 93       	push	r17
 200:	cf 93       	push	r28
 202:	df 93       	push	r29
 204:	20 91 dd 03 	lds	r18, 0x03DD	; 0x8003dd <cmd+0x2>
 208:	30 91 de 03 	lds	r19, 0x03DE	; 0x8003de <cmd+0x3>
 20c:	23 2b       	or	r18, r19
 20e:	09 f4       	brne	.+2      	; 0x212 <cmdGetPara+0x20>
 210:	72 c0       	rjmp	.+228    	; 0x2f6 <cmdGetPara+0x104>
 212:	c4 2e       	mov	r12, r20
 214:	8b 01       	movw	r16, r22
 216:	f9 2e       	mov	r15, r25
 218:	e8 2e       	mov	r14, r24
 21a:	80 e0       	ldi	r24, 0x00	; 0
 21c:	90 e0       	ldi	r25, 0x00	; 0
 21e:	d1 2c       	mov	r13, r1
 220:	cb ed       	ldi	r28, 0xDB	; 219
 222:	d3 e0       	ldi	r29, 0x03	; 3
 224:	0f 2e       	mov	r0, r31
 226:	f7 e2       	ldi	r31, 0x27	; 39
 228:	bf 2e       	mov	r11, r31
 22a:	f0 2d       	mov	r31, r0
 22c:	b8 9e       	mul	r11, r24
 22e:	90 01       	movw	r18, r0
 230:	b9 9e       	mul	r11, r25
 232:	30 0d       	add	r19, r0
 234:	11 24       	eor	r1, r1
 236:	68 81       	ld	r22, Y
 238:	79 81       	ldd	r23, Y+1	; 0x01
 23a:	62 0f       	add	r22, r18
 23c:	73 1f       	adc	r23, r19
 23e:	6c 5e       	subi	r22, 0xEC	; 236
 240:	7f 4f       	sbci	r23, 0xFF	; 255
 242:	c8 01       	movw	r24, r16
 244:	0e 94 63 00 	call	0xc6	; 0xc6 <cmdSearch>
 248:	89 2b       	or	r24, r25
 24a:	09 f0       	breq	.+2      	; 0x24e <cmdGetPara+0x5c>
 24c:	57 c0       	rjmp	.+174    	; 0x2fc <cmdGetPara+0x10a>
 24e:	d3 94       	inc	r13
 250:	8d 2d       	mov	r24, r13
 252:	90 e0       	ldi	r25, 0x00	; 0
 254:	2a 81       	ldd	r18, Y+2	; 0x02
 256:	3b 81       	ldd	r19, Y+3	; 0x03
 258:	82 17       	cp	r24, r18
 25a:	93 07       	cpc	r25, r19
 25c:	38 f3       	brcs	.-50     	; 0x22c <cmdGetPara+0x3a>
 25e:	4b c0       	rjmp	.+150    	; 0x2f6 <cmdGetPara+0x104>
 260:	6a e3       	ldi	r22, 0x3A	; 58
 262:	70 e0       	ldi	r23, 0x00	; 0
 264:	c8 01       	movw	r24, r16
 266:	0e 94 39 05 	call	0xa72	; 0xa72 <strchr>
 26a:	01 96       	adiw	r24, 0x01	; 1
 26c:	c0 e0       	ldi	r28, 0x00	; 0
 26e:	6c e2       	ldi	r22, 0x2C	; 44
 270:	70 e0       	ldi	r23, 0x00	; 0
 272:	0e 94 39 05 	call	0xa72	; 0xa72 <strchr>
 276:	01 96       	adiw	r24, 0x01	; 1
 278:	cf 5f       	subi	r28, 0xFF	; 255
 27a:	cc 12       	cpse	r12, r28
 27c:	f8 cf       	rjmp	.-16     	; 0x26e <cmdGetPara+0x7c>
 27e:	06 c0       	rjmp	.+12     	; 0x28c <cmdGetPara+0x9a>
 280:	6a e3       	ldi	r22, 0x3A	; 58
 282:	70 e0       	ldi	r23, 0x00	; 0
 284:	c8 01       	movw	r24, r16
 286:	0e 94 39 05 	call	0xa72	; 0xa72 <strchr>
 28a:	01 96       	adiw	r24, 0x01	; 1
 28c:	00 97       	sbiw	r24, 0x00	; 0
 28e:	d9 f0       	breq	.+54     	; 0x2c6 <cmdGetPara+0xd4>
 290:	fc 01       	movw	r30, r24
 292:	20 81       	ld	r18, Z
 294:	22 23       	and	r18, r18
 296:	d1 f0       	breq	.+52     	; 0x2cc <cmdGetPara+0xda>
 298:	2c 32       	cpi	r18, 0x2C	; 44
 29a:	d9 f0       	breq	.+54     	; 0x2d2 <cmdGetPara+0xe0>
 29c:	2b 33       	cpi	r18, 0x3B	; 59
 29e:	e1 f0       	breq	.+56     	; 0x2d8 <cmdGetPara+0xe6>
 2a0:	23 32       	cpi	r18, 0x23	; 35
 2a2:	e9 f0       	breq	.+58     	; 0x2de <cmdGetPara+0xec>
 2a4:	ae 2d       	mov	r26, r14
 2a6:	bf 2d       	mov	r27, r15
 2a8:	31 96       	adiw	r30, 0x01	; 1
 2aa:	02 c0       	rjmp	.+4      	; 0x2b0 <cmdGetPara+0xbe>
 2ac:	23 32       	cpi	r18, 0x23	; 35
 2ae:	d1 f0       	breq	.+52     	; 0x2e4 <cmdGetPara+0xf2>
 2b0:	2d 93       	st	X+, r18
 2b2:	21 91       	ld	r18, Z+
 2b4:	22 23       	and	r18, r18
 2b6:	c9 f0       	breq	.+50     	; 0x2ea <cmdGetPara+0xf8>
 2b8:	2c 32       	cpi	r18, 0x2C	; 44
 2ba:	d1 f0       	breq	.+52     	; 0x2f0 <cmdGetPara+0xfe>
 2bc:	2b 33       	cpi	r18, 0x3B	; 59
 2be:	b1 f7       	brne	.-20     	; 0x2ac <cmdGetPara+0xba>
 2c0:	8e 2d       	mov	r24, r14
 2c2:	9f 2d       	mov	r25, r15
 2c4:	1e c0       	rjmp	.+60     	; 0x302 <cmdGetPara+0x110>
 2c6:	80 e0       	ldi	r24, 0x00	; 0
 2c8:	90 e0       	ldi	r25, 0x00	; 0
 2ca:	1b c0       	rjmp	.+54     	; 0x302 <cmdGetPara+0x110>
 2cc:	8e 2d       	mov	r24, r14
 2ce:	9f 2d       	mov	r25, r15
 2d0:	18 c0       	rjmp	.+48     	; 0x302 <cmdGetPara+0x110>
 2d2:	8e 2d       	mov	r24, r14
 2d4:	9f 2d       	mov	r25, r15
 2d6:	15 c0       	rjmp	.+42     	; 0x302 <cmdGetPara+0x110>
 2d8:	8e 2d       	mov	r24, r14
 2da:	9f 2d       	mov	r25, r15
 2dc:	12 c0       	rjmp	.+36     	; 0x302 <cmdGetPara+0x110>
 2de:	80 e0       	ldi	r24, 0x00	; 0
 2e0:	90 e0       	ldi	r25, 0x00	; 0
 2e2:	0f c0       	rjmp	.+30     	; 0x302 <cmdGetPara+0x110>
 2e4:	80 e0       	ldi	r24, 0x00	; 0
 2e6:	90 e0       	ldi	r25, 0x00	; 0
 2e8:	0c c0       	rjmp	.+24     	; 0x302 <cmdGetPara+0x110>
 2ea:	8e 2d       	mov	r24, r14
 2ec:	9f 2d       	mov	r25, r15
 2ee:	09 c0       	rjmp	.+18     	; 0x302 <cmdGetPara+0x110>
 2f0:	8e 2d       	mov	r24, r14
 2f2:	9f 2d       	mov	r25, r15
 2f4:	06 c0       	rjmp	.+12     	; 0x302 <cmdGetPara+0x110>
 2f6:	80 e0       	ldi	r24, 0x00	; 0
 2f8:	90 e0       	ldi	r25, 0x00	; 0
 2fa:	03 c0       	rjmp	.+6      	; 0x302 <cmdGetPara+0x110>
 2fc:	c1 10       	cpse	r12, r1
 2fe:	b0 cf       	rjmp	.-160    	; 0x260 <cmdGetPara+0x6e>
 300:	bf cf       	rjmp	.-130    	; 0x280 <cmdGetPara+0x8e>
 302:	df 91       	pop	r29
 304:	cf 91       	pop	r28
 306:	1f 91       	pop	r17
 308:	0f 91       	pop	r16
 30a:	ff 90       	pop	r15
 30c:	ef 90       	pop	r14
 30e:	df 90       	pop	r13
 310:	cf 90       	pop	r12
 312:	bf 90       	pop	r11
 314:	08 95       	ret

00000316 <cmdHelp>:

char				*cmdHelp			( char *helpBuff )										
{
 316:	8f 92       	push	r8
 318:	9f 92       	push	r9
 31a:	af 92       	push	r10
 31c:	bf 92       	push	r11
 31e:	cf 92       	push	r12
 320:	df 92       	push	r13
 322:	ef 92       	push	r14
 324:	ff 92       	push	r15
 326:	0f 93       	push	r16
 328:	1f 93       	push	r17
 32a:	cf 93       	push	r28
 32c:	df 93       	push	r29
 32e:	ec 01       	movw	r28, r24
	memset( helpBuff , 0 , strlen( helpBuff ) );
 330:	fc 01       	movw	r30, r24
 332:	01 90       	ld	r0, Z+
 334:	00 20       	and	r0, r0
 336:	e9 f7       	brne	.-6      	; 0x332 <cmdHelp+0x1c>
 338:	31 97       	sbiw	r30, 0x01	; 1
 33a:	af 01       	movw	r20, r30
 33c:	48 1b       	sub	r20, r24
 33e:	59 0b       	sbc	r21, r25
 340:	60 e0       	ldi	r22, 0x00	; 0
 342:	70 e0       	ldi	r23, 0x00	; 0
 344:	0e 94 27 05 	call	0xa4e	; 0xa4e <memset>
	
	strcpy( ( char * ) helpBuff , "Kommando Syntax: " );
 348:	82 e1       	ldi	r24, 0x12	; 18
 34a:	e2 e7       	ldi	r30, 0x72	; 114
 34c:	f0 e0       	ldi	r31, 0x00	; 0
 34e:	de 01       	movw	r26, r28
 350:	01 90       	ld	r0, Z+
 352:	0d 92       	st	X+, r0
 354:	8a 95       	dec	r24
 356:	e1 f7       	brne	.-8      	; 0x350 <cmdHelp+0x3a>
	strcat( ( char * ) helpBuff , "[KOMMANDO WORD][PARAMETER START][PARAMETER][KOMMANDO ENDE]\r\n" );
 358:	de 01       	movw	r26, r28
 35a:	0d 90       	ld	r0, X+
 35c:	00 20       	and	r0, r0
 35e:	e9 f7       	brne	.-6      	; 0x35a <cmdHelp+0x44>
 360:	11 97       	sbiw	r26, 0x01	; 1
 362:	8d e3       	ldi	r24, 0x3D	; 61
 364:	e4 e8       	ldi	r30, 0x84	; 132
 366:	f0 e0       	ldi	r31, 0x00	; 0
 368:	01 90       	ld	r0, Z+
 36a:	0d 92       	st	X+, r0
 36c:	8a 95       	dec	r24
 36e:	e1 f7       	brne	.-8      	; 0x368 <cmdHelp+0x52>
	
	strcat( ( char * ) helpBuff , "'" );
 370:	fe 01       	movw	r30, r28
 372:	01 90       	ld	r0, Z+
 374:	00 20       	and	r0, r0
 376:	e9 f7       	brne	.-6      	; 0x372 <cmdHelp+0x5c>
 378:	31 97       	sbiw	r30, 0x01	; 1
 37a:	87 e2       	ldi	r24, 0x27	; 39
 37c:	90 e0       	ldi	r25, 0x00	; 0
 37e:	91 83       	std	Z+1, r25	; 0x01
 380:	80 83       	st	Z, r24
	strcat( ( char * ) helpBuff , CMD_RAW_DATA_BEGINN );	
 382:	fe 01       	movw	r30, r28
 384:	01 90       	ld	r0, Z+
 386:	00 20       	and	r0, r0
 388:	e9 f7       	brne	.-6      	; 0x384 <cmdHelp+0x6e>
 38a:	31 97       	sbiw	r30, 0x01	; 1
 38c:	2a e3       	ldi	r18, 0x3A	; 58
 38e:	30 e0       	ldi	r19, 0x00	; 0
 390:	31 83       	std	Z+1, r19	; 0x01
 392:	20 83       	st	Z, r18
	strcat( ( char * ) helpBuff , "' ->[PARA. START]\r\n" );
 394:	de 01       	movw	r26, r28
 396:	0d 90       	ld	r0, X+
 398:	00 20       	and	r0, r0
 39a:	e9 f7       	brne	.-6      	; 0x396 <cmdHelp+0x80>
 39c:	11 97       	sbiw	r26, 0x01	; 1
 39e:	24 e1       	ldi	r18, 0x14	; 20
 3a0:	e1 ec       	ldi	r30, 0xC1	; 193
 3a2:	f0 e0       	ldi	r31, 0x00	; 0
 3a4:	01 90       	ld	r0, Z+
 3a6:	0d 92       	st	X+, r0
 3a8:	2a 95       	dec	r18
 3aa:	e1 f7       	brne	.-8      	; 0x3a4 <cmdHelp+0x8e>

	strcat( ( char * ) helpBuff , "'" );
 3ac:	fe 01       	movw	r30, r28
 3ae:	01 90       	ld	r0, Z+
 3b0:	00 20       	and	r0, r0
 3b2:	e9 f7       	brne	.-6      	; 0x3ae <cmdHelp+0x98>
 3b4:	31 97       	sbiw	r30, 0x01	; 1
 3b6:	91 83       	std	Z+1, r25	; 0x01
 3b8:	80 83       	st	Z, r24
	strcat( ( char * ) helpBuff , CMD_RAW_PARA_DELIMITER );
 3ba:	fe 01       	movw	r30, r28
 3bc:	01 90       	ld	r0, Z+
 3be:	00 20       	and	r0, r0
 3c0:	e9 f7       	brne	.-6      	; 0x3bc <cmdHelp+0xa6>
 3c2:	31 97       	sbiw	r30, 0x01	; 1
 3c4:	2c e2       	ldi	r18, 0x2C	; 44
 3c6:	30 e0       	ldi	r19, 0x00	; 0
 3c8:	31 83       	std	Z+1, r19	; 0x01
 3ca:	20 83       	st	Z, r18
	strcat( ( char * ) helpBuff , "' ->[PARA. TRENNER]\r\n" );
 3cc:	de 01       	movw	r26, r28
 3ce:	0d 90       	ld	r0, X+
 3d0:	00 20       	and	r0, r0
 3d2:	e9 f7       	brne	.-6      	; 0x3ce <cmdHelp+0xb8>
 3d4:	11 97       	sbiw	r26, 0x01	; 1
 3d6:	26 e1       	ldi	r18, 0x16	; 22
 3d8:	e5 ed       	ldi	r30, 0xD5	; 213
 3da:	f0 e0       	ldi	r31, 0x00	; 0
 3dc:	01 90       	ld	r0, Z+
 3de:	0d 92       	st	X+, r0
 3e0:	2a 95       	dec	r18
 3e2:	e1 f7       	brne	.-8      	; 0x3dc <cmdHelp+0xc6>

	strcat( ( char * ) helpBuff , "'" );
 3e4:	fe 01       	movw	r30, r28
 3e6:	01 90       	ld	r0, Z+
 3e8:	00 20       	and	r0, r0
 3ea:	e9 f7       	brne	.-6      	; 0x3e6 <cmdHelp+0xd0>
 3ec:	31 97       	sbiw	r30, 0x01	; 1
 3ee:	91 83       	std	Z+1, r25	; 0x01
 3f0:	80 83       	st	Z, r24
	
	uint8_t pos = strlen( helpBuff );
 3f2:	fe 01       	movw	r30, r28
 3f4:	01 90       	ld	r0, Z+
 3f6:	00 20       	and	r0, r0
 3f8:	e9 f7       	brne	.-6      	; 0x3f4 <cmdHelp+0xde>
 3fa:	31 97       	sbiw	r30, 0x01	; 1
 3fc:	ec 1b       	sub	r30, r28
 3fe:	fd 0b       	sbc	r31, r29
	{
		strcat( ( char * ) helpBuff , "\\0" );
	}
	else
	{
		helpBuff[ pos ] = CMD_DATA_END;
 400:	ce 01       	movw	r24, r28
 402:	8e 0f       	add	r24, r30
 404:	91 1d       	adc	r25, r1
 406:	fc 01       	movw	r30, r24
 408:	8b e3       	ldi	r24, 0x3B	; 59
 40a:	80 83       	st	Z, r24
	}
	strcat( ( char * ) helpBuff , "' ->[KOMMANDO ENDE]\r\n\n" );
 40c:	de 01       	movw	r26, r28
 40e:	0d 90       	ld	r0, X+
 410:	00 20       	and	r0, r0
 412:	e9 f7       	brne	.-6      	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
 414:	11 97       	sbiw	r26, 0x01	; 1
 416:	87 e1       	ldi	r24, 0x17	; 23
 418:	eb ee       	ldi	r30, 0xEB	; 235
 41a:	f0 e0       	ldi	r31, 0x00	; 0
 41c:	01 90       	ld	r0, Z+
 41e:	0d 92       	st	X+, r0
 420:	8a 95       	dec	r24
 422:	e1 f7       	brne	.-8      	; 0x41c <__LOCK_REGION_LENGTH__+0x1c>


 	strcat( ( char * ) helpBuff , "Kommandos:\r\n\n" );
 424:	de 01       	movw	r26, r28
 426:	0d 90       	ld	r0, X+
 428:	00 20       	and	r0, r0
 42a:	e9 f7       	brne	.-6      	; 0x426 <__LOCK_REGION_LENGTH__+0x26>
 42c:	11 97       	sbiw	r26, 0x01	; 1
 42e:	8e e0       	ldi	r24, 0x0E	; 14
 430:	e2 e0       	ldi	r30, 0x02	; 2
 432:	f1 e0       	ldi	r31, 0x01	; 1
 434:	01 90       	ld	r0, Z+
 436:	0d 92       	st	X+, r0
 438:	8a 95       	dec	r24
 43a:	e1 f7       	brne	.-8      	; 0x434 <__LOCK_REGION_LENGTH__+0x34>
	
	for ( uint8_t x = 0 ; x < cmd.tabLen ; x++ )
 43c:	80 91 dd 03 	lds	r24, 0x03DD	; 0x8003dd <cmd+0x2>
 440:	90 91 de 03 	lds	r25, 0x03DE	; 0x8003de <cmd+0x3>
 444:	89 2b       	or	r24, r25
 446:	09 f4       	brne	.+2      	; 0x44a <__LOCK_REGION_LENGTH__+0x4a>
 448:	51 c0       	rjmp	.+162    	; 0x4ec <__LOCK_REGION_LENGTH__+0xec>
 44a:	80 e0       	ldi	r24, 0x00	; 0
 44c:	90 e0       	ldi	r25, 0x00	; 0
 44e:	91 2c       	mov	r9, r1
	{
		strcat( ( char * ) helpBuff , cmd.table[x].name );
 450:	0f 2e       	mov	r0, r31
 452:	f7 e2       	ldi	r31, 0x27	; 39
 454:	8f 2e       	mov	r8, r31
 456:	f0 2d       	mov	r31, r0
 458:	0f 2e       	mov	r0, r31
 45a:	fb ed       	ldi	r31, 0xDB	; 219
 45c:	ef 2e       	mov	r14, r31
 45e:	f3 e0       	ldi	r31, 0x03	; 3
 460:	ff 2e       	mov	r15, r31
 462:	f0 2d       	mov	r31, r0
		strcat( ( char * ) helpBuff , " " );
 464:	68 94       	set
 466:	aa 24       	eor	r10, r10
 468:	a5 f8       	bld	r10, 5
 46a:	b1 2c       	mov	r11, r1
		strcat( ( char * ) helpBuff , cmd.table[x].instruction );
		strcat( ( char * ) helpBuff , cmd.table[x].syntax );
		strcat( ( char * ) helpBuff , "\r\n" );
 46c:	0f 2e       	mov	r0, r31
 46e:	fd e0       	ldi	r31, 0x0D	; 13
 470:	cf 2e       	mov	r12, r31
 472:	fa e0       	ldi	r31, 0x0A	; 10
 474:	df 2e       	mov	r13, r31
 476:	f0 2d       	mov	r31, r0

 	strcat( ( char * ) helpBuff , "Kommandos:\r\n\n" );
	
	for ( uint8_t x = 0 ; x < cmd.tabLen ; x++ )
	{
		strcat( ( char * ) helpBuff , cmd.table[x].name );
 478:	88 9e       	mul	r8, r24
 47a:	80 01       	movw	r16, r0
 47c:	89 9e       	mul	r8, r25
 47e:	10 0d       	add	r17, r0
 480:	11 24       	eor	r1, r1
 482:	f7 01       	movw	r30, r14
 484:	60 81       	ld	r22, Z
 486:	71 81       	ldd	r23, Z+1	; 0x01
 488:	60 0f       	add	r22, r16
 48a:	71 1f       	adc	r23, r17
 48c:	ce 01       	movw	r24, r28
 48e:	0e 94 2e 05 	call	0xa5c	; 0xa5c <strcat>
		strcat( ( char * ) helpBuff , " " );
 492:	fe 01       	movw	r30, r28
 494:	01 90       	ld	r0, Z+
 496:	00 20       	and	r0, r0
 498:	e9 f7       	brne	.-6      	; 0x494 <__LOCK_REGION_LENGTH__+0x94>
 49a:	31 97       	sbiw	r30, 0x01	; 1
 49c:	b1 82       	std	Z+1, r11	; 0x01
 49e:	a0 82       	st	Z, r10
		strcat( ( char * ) helpBuff , cmd.table[x].instruction );
 4a0:	f7 01       	movw	r30, r14
 4a2:	60 81       	ld	r22, Z
 4a4:	71 81       	ldd	r23, Z+1	; 0x01
 4a6:	60 0f       	add	r22, r16
 4a8:	71 1f       	adc	r23, r17
 4aa:	6c 5e       	subi	r22, 0xEC	; 236
 4ac:	7f 4f       	sbci	r23, 0xFF	; 255
 4ae:	ce 01       	movw	r24, r28
 4b0:	0e 94 2e 05 	call	0xa5c	; 0xa5c <strcat>
		strcat( ( char * ) helpBuff , cmd.table[x].syntax );
 4b4:	f7 01       	movw	r30, r14
 4b6:	80 81       	ld	r24, Z
 4b8:	91 81       	ldd	r25, Z+1	; 0x01
 4ba:	fc 01       	movw	r30, r24
 4bc:	e0 0f       	add	r30, r16
 4be:	f1 1f       	adc	r31, r17
 4c0:	65 a1       	ldd	r22, Z+37	; 0x25
 4c2:	76 a1       	ldd	r23, Z+38	; 0x26
 4c4:	ce 01       	movw	r24, r28
 4c6:	0e 94 2e 05 	call	0xa5c	; 0xa5c <strcat>
		strcat( ( char * ) helpBuff , "\r\n" );
 4ca:	fe 01       	movw	r30, r28
 4cc:	01 90       	ld	r0, Z+
 4ce:	00 20       	and	r0, r0
 4d0:	e9 f7       	brne	.-6      	; 0x4cc <__LOCK_REGION_LENGTH__+0xcc>
 4d2:	31 97       	sbiw	r30, 0x01	; 1
 4d4:	d1 82       	std	Z+1, r13	; 0x01
 4d6:	c0 82       	st	Z, r12
 4d8:	12 82       	std	Z+2, r1	; 0x02
	strcat( ( char * ) helpBuff , "' ->[KOMMANDO ENDE]\r\n\n" );


 	strcat( ( char * ) helpBuff , "Kommandos:\r\n\n" );
	
	for ( uint8_t x = 0 ; x < cmd.tabLen ; x++ )
 4da:	93 94       	inc	r9
 4dc:	89 2d       	mov	r24, r9
 4de:	90 e0       	ldi	r25, 0x00	; 0
 4e0:	f7 01       	movw	r30, r14
 4e2:	22 81       	ldd	r18, Z+2	; 0x02
 4e4:	33 81       	ldd	r19, Z+3	; 0x03
 4e6:	82 17       	cp	r24, r18
 4e8:	93 07       	cpc	r25, r19
 4ea:	30 f2       	brcs	.-116    	; 0x478 <__LOCK_REGION_LENGTH__+0x78>
		strcat( ( char * ) helpBuff , cmd.table[x].syntax );
		strcat( ( char * ) helpBuff , "\r\n" );
	}

	return helpBuff;
 4ec:	ce 01       	movw	r24, r28
 4ee:	df 91       	pop	r29
 4f0:	cf 91       	pop	r28
 4f2:	1f 91       	pop	r17
 4f4:	0f 91       	pop	r16
 4f6:	ff 90       	pop	r15
 4f8:	ef 90       	pop	r14
 4fa:	df 90       	pop	r13
 4fc:	cf 90       	pop	r12
 4fe:	bf 90       	pop	r11
 500:	af 90       	pop	r10
 502:	9f 90       	pop	r9
 504:	8f 90       	pop	r8
 506:	08 95       	ret

00000508 <__vector_13>:
ISR (UART0_RECEIVE_INTERRUPT)	
/*************************************************************************
Function: UART Receive Complete interrupt
Purpose:  called when the UART has received a character
**************************************************************************/
{
 508:	1f 92       	push	r1
 50a:	0f 92       	push	r0
 50c:	0f b6       	in	r0, 0x3f	; 63
 50e:	0f 92       	push	r0
 510:	11 24       	eor	r1, r1
 512:	2f 93       	push	r18
 514:	8f 93       	push	r24
 516:	9f 93       	push	r25
 518:	ef 93       	push	r30
 51a:	ff 93       	push	r31
    unsigned char usr;
    unsigned char lastRxError;
 
 
    /* read UART status register and UART data register */ 
    usr  = UART0_STATUS;
 51c:	8b b1       	in	r24, 0x0b	; 11
    data = UART0_DATA;
 51e:	2c b1       	in	r18, 0x0c	; 12
    
    /* */
#if defined( AT90_UART )
    lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
#elif defined( ATMEGA_USART )
    lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
 520:	88 71       	andi	r24, 0x18	; 24
#elif defined( AT90USB_USART )
    lastRxError = (usr & (_BV(FE1)|_BV(DOR1)) );
#endif
        
    /* calculate buffer index */ 
    tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
 522:	e0 91 36 02 	lds	r30, 0x0236	; 0x800236 <UART_RxHead>
 526:	ef 5f       	subi	r30, 0xFF	; 255
 528:	ef 73       	andi	r30, 0x3F	; 63
    
    if ( tmphead == UART_RxTail ) {
 52a:	90 91 35 02 	lds	r25, 0x0235	; 0x800235 <UART_RxTail>
 52e:	e9 17       	cp	r30, r25
 530:	39 f0       	breq	.+14     	; 0x540 <__vector_13+0x38>
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
    }else{
        /* store new index */
        UART_RxHead = tmphead;
 532:	e0 93 36 02 	sts	0x0236, r30	; 0x800236 <UART_RxHead>
        /* store received data in buffer */
        UART_RxBuf[tmphead] = data;
 536:	f0 e0       	ldi	r31, 0x00	; 0
 538:	e7 5c       	subi	r30, 0xC7	; 199
 53a:	fd 4f       	sbci	r31, 0xFD	; 253
 53c:	20 83       	st	Z, r18
 53e:	01 c0       	rjmp	.+2      	; 0x542 <__vector_13+0x3a>
    /* calculate buffer index */ 
    tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
    
    if ( tmphead == UART_RxTail ) {
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
 540:	82 e0       	ldi	r24, 0x02	; 2
        /* store new index */
        UART_RxHead = tmphead;
        /* store received data in buffer */
        UART_RxBuf[tmphead] = data;
    }
    UART_LastRxError |= lastRxError;   
 542:	90 91 34 02 	lds	r25, 0x0234	; 0x800234 <UART_LastRxError>
 546:	89 2b       	or	r24, r25
 548:	80 93 34 02 	sts	0x0234, r24	; 0x800234 <UART_LastRxError>
}
 54c:	ff 91       	pop	r31
 54e:	ef 91       	pop	r30
 550:	9f 91       	pop	r25
 552:	8f 91       	pop	r24
 554:	2f 91       	pop	r18
 556:	0f 90       	pop	r0
 558:	0f be       	out	0x3f, r0	; 63
 55a:	0f 90       	pop	r0
 55c:	1f 90       	pop	r1
 55e:	18 95       	reti

00000560 <__vector_14>:
ISR (UART0_TRANSMIT_INTERRUPT)
/*************************************************************************
Function: UART Data Register Empty interrupt
Purpose:  called when the UART is ready to transmit the next byte
**************************************************************************/
{
 560:	1f 92       	push	r1
 562:	0f 92       	push	r0
 564:	0f b6       	in	r0, 0x3f	; 63
 566:	0f 92       	push	r0
 568:	11 24       	eor	r1, r1
 56a:	8f 93       	push	r24
 56c:	9f 93       	push	r25
 56e:	ef 93       	push	r30
 570:	ff 93       	push	r31
    unsigned char tmptail;

    
    if ( UART_TxHead != UART_TxTail) {
 572:	90 91 38 02 	lds	r25, 0x0238	; 0x800238 <UART_TxHead>
 576:	80 91 37 02 	lds	r24, 0x0237	; 0x800237 <UART_TxTail>
 57a:	98 17       	cp	r25, r24
 57c:	61 f0       	breq	.+24     	; 0x596 <__vector_14+0x36>
        /* calculate and store new buffer index */
        tmptail = (UART_TxTail + 1) & UART_TX_BUFFER_MASK;
 57e:	e0 91 37 02 	lds	r30, 0x0237	; 0x800237 <UART_TxTail>
 582:	ef 5f       	subi	r30, 0xFF	; 255
 584:	ef 71       	andi	r30, 0x1F	; 31
        UART_TxTail = tmptail;
 586:	e0 93 37 02 	sts	0x0237, r30	; 0x800237 <UART_TxTail>
        /* get one byte from buffer and write it to UART */
        UART0_DATA = UART_TxBuf[tmptail];  /* start transmission */
 58a:	f0 e0       	ldi	r31, 0x00	; 0
 58c:	e7 58       	subi	r30, 0x87	; 135
 58e:	fd 4f       	sbci	r31, 0xFD	; 253
 590:	80 81       	ld	r24, Z
 592:	8c b9       	out	0x0c, r24	; 12
 594:	01 c0       	rjmp	.+2      	; 0x598 <__vector_14+0x38>
    }else{
        /* tx buffer empty, disable UDRE interrupt */
        UART0_CONTROL &= ~_BV(UART0_UDRIE);
 596:	55 98       	cbi	0x0a, 5	; 10
    }
}
 598:	ff 91       	pop	r31
 59a:	ef 91       	pop	r30
 59c:	9f 91       	pop	r25
 59e:	8f 91       	pop	r24
 5a0:	0f 90       	pop	r0
 5a2:	0f be       	out	0x3f, r0	; 63
 5a4:	0f 90       	pop	r0
 5a6:	1f 90       	pop	r1
 5a8:	18 95       	reti

000005aa <uart_init>:
Input:    baudrate using macro UART_BAUD_SELECT()
Returns:  none
**************************************************************************/
void uart_init(unsigned int baudrate)
{
    UART_TxHead = 0;
 5aa:	10 92 38 02 	sts	0x0238, r1	; 0x800238 <UART_TxHead>
    UART_TxTail = 0;
 5ae:	10 92 37 02 	sts	0x0237, r1	; 0x800237 <UART_TxTail>
    UART_RxHead = 0;
 5b2:	10 92 36 02 	sts	0x0236, r1	; 0x800236 <UART_RxHead>
    UART_RxTail = 0;
 5b6:	10 92 35 02 	sts	0x0235, r1	; 0x800235 <UART_RxTail>
    /* enable UART receiver and transmmitter and receive complete interrupt */
    UART0_CONTROL = _BV(RXCIE)|_BV(RXEN)|_BV(TXEN);

#elif defined (ATMEGA_USART)
    /* Set baud rate */
    if ( baudrate & 0x8000 )
 5ba:	99 23       	and	r25, r25
 5bc:	1c f4       	brge	.+6      	; 0x5c4 <uart_init+0x1a>
    {
    	 UART0_STATUS = (1<<U2X);  //Enable 2x speed 
 5be:	22 e0       	ldi	r18, 0x02	; 2
 5c0:	2b b9       	out	0x0b, r18	; 11
    	 baudrate &= ~0x8000;
 5c2:	9f 77       	andi	r25, 0x7F	; 127
    }
    UBRRH = (unsigned char)(baudrate>>8);
 5c4:	90 bd       	out	0x20, r25	; 32
    UBRRL = (unsigned char) baudrate;
 5c6:	89 b9       	out	0x09, r24	; 9
   
    /* Enable USART receiver and transmitter and receive complete interrupt */
    UART0_CONTROL = _BV(RXCIE)|(1<<RXEN)|(1<<TXEN);
 5c8:	88 e9       	ldi	r24, 0x98	; 152
 5ca:	8a b9       	out	0x0a, r24	; 10
    
    /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
    #ifdef URSEL
    UCSRC = (1<<URSEL)|(3<<UCSZ0);
 5cc:	86 e8       	ldi	r24, 0x86	; 134
 5ce:	80 bd       	out	0x20, r24	; 32
 5d0:	08 95       	ret

000005d2 <uart_getc>:
{    
    unsigned char tmptail;
    unsigned char data;


    if ( UART_RxHead == UART_RxTail ) {
 5d2:	90 91 36 02 	lds	r25, 0x0236	; 0x800236 <UART_RxHead>
 5d6:	80 91 35 02 	lds	r24, 0x0235	; 0x800235 <UART_RxTail>
 5da:	98 17       	cp	r25, r24
 5dc:	81 f0       	breq	.+32     	; 0x5fe <uart_getc+0x2c>
        return UART_NO_DATA;   /* no data available */
    }
    
    /* calculate /store buffer index */
    tmptail = (UART_RxTail + 1) & UART_RX_BUFFER_MASK;
 5de:	e0 91 35 02 	lds	r30, 0x0235	; 0x800235 <UART_RxTail>
 5e2:	ef 5f       	subi	r30, 0xFF	; 255
 5e4:	ef 73       	andi	r30, 0x3F	; 63
    UART_RxTail = tmptail; 
 5e6:	e0 93 35 02 	sts	0x0235, r30	; 0x800235 <UART_RxTail>
    
    /* get data from receive buffer */
    data = UART_RxBuf[tmptail];
 5ea:	f0 e0       	ldi	r31, 0x00	; 0
 5ec:	e7 5c       	subi	r30, 0xC7	; 199
 5ee:	fd 4f       	sbci	r31, 0xFD	; 253
 5f0:	80 81       	ld	r24, Z
    
    data = (UART_LastRxError << 8) + data;
 5f2:	90 91 34 02 	lds	r25, 0x0234	; 0x800234 <UART_LastRxError>
    UART_LastRxError = 0;
 5f6:	10 92 34 02 	sts	0x0234, r1	; 0x800234 <UART_LastRxError>
    return data;
 5fa:	90 e0       	ldi	r25, 0x00	; 0
 5fc:	08 95       	ret
    unsigned char tmptail;
    unsigned char data;


    if ( UART_RxHead == UART_RxTail ) {
        return UART_NO_DATA;   /* no data available */
 5fe:	80 e0       	ldi	r24, 0x00	; 0
 600:	91 e0       	ldi	r25, 0x01	; 1
    
    data = (UART_LastRxError << 8) + data;
    UART_LastRxError = 0;
    return data;

}/* uart_getc */
 602:	08 95       	ret

00000604 <uart_putc>:
void uart_putc(unsigned char data)
{
    unsigned char tmphead;

    
    tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
 604:	20 91 38 02 	lds	r18, 0x0238	; 0x800238 <UART_TxHead>
 608:	2f 5f       	subi	r18, 0xFF	; 255
 60a:	2f 71       	andi	r18, 0x1F	; 31
    
    while ( tmphead == UART_TxTail ){
 60c:	90 91 37 02 	lds	r25, 0x0237	; 0x800237 <UART_TxTail>
 610:	29 17       	cp	r18, r25
 612:	e1 f3       	breq	.-8      	; 0x60c <uart_putc+0x8>
        ;/* wait for free space in buffer */
    }
    
    UART_TxBuf[tmphead] = data;
 614:	e2 2f       	mov	r30, r18
 616:	f0 e0       	ldi	r31, 0x00	; 0
 618:	e7 58       	subi	r30, 0x87	; 135
 61a:	fd 4f       	sbci	r31, 0xFD	; 253
 61c:	80 83       	st	Z, r24
    UART_TxHead = tmphead;
 61e:	20 93 38 02 	sts	0x0238, r18	; 0x800238 <UART_TxHead>

    /* enable UDRE interrupt */
    UART0_CONTROL    |= _BV(UART0_UDRIE);
 622:	55 9a       	sbi	0x0a, 5	; 10
 624:	08 95       	ret

00000626 <uart_puts>:
Purpose:  transmit string to UART
Input:    string to be transmitted
Returns:  none          
**************************************************************************/
void uart_puts(const char *s )
{
 626:	cf 93       	push	r28
 628:	df 93       	push	r29
 62a:	ec 01       	movw	r28, r24
    while (*s) 
 62c:	88 81       	ld	r24, Y
 62e:	88 23       	and	r24, r24
 630:	31 f0       	breq	.+12     	; 0x63e <uart_puts+0x18>
 632:	21 96       	adiw	r28, 0x01	; 1
      uart_putc(*s++);
 634:	0e 94 02 03 	call	0x604	; 0x604 <uart_putc>
Input:    string to be transmitted
Returns:  none          
**************************************************************************/
void uart_puts(const char *s )
{
    while (*s) 
 638:	89 91       	ld	r24, Y+
 63a:	81 11       	cpse	r24, r1
 63c:	fb cf       	rjmp	.-10     	; 0x634 <uart_puts+0xe>
      uart_putc(*s++);

}/* uart_puts */
 63e:	df 91       	pop	r29
 640:	cf 91       	pop	r28
 642:	08 95       	ret

00000644 <hardware_init>:
#include "hard_def.h"

void hardware_init(void)
{
	/* gpios as output */
	DDR(GLCD_PORT) 	 			|= ((1<<GLCD_CS1_bp) | (1<<GLCD_RES_bp) | (1<<GLCD_A0_bp) | (1<<GLCD_SCL_bp) | (1<<GLCD_DATA_bp));
 644:	8a b3       	in	r24, 0x1a	; 26
 646:	88 6f       	ori	r24, 0xF8	; 248
 648:	8a bb       	out	0x1a, r24	; 26
	DDR(GLCD_LED_PORT) 			|= ((1<<GLCD_LED_BLUE_bp) | (1<<GLCD_LED_GREEN_bp) | (1<<GLCD_LED_RED_bp));
 64a:	84 b3       	in	r24, 0x14	; 20
 64c:	80 6e       	ori	r24, 0xE0	; 224
 64e:	84 bb       	out	0x14, r24	; 20
	DDR(LED_HEARTBEAT_PORT) 	|= ( 1<<LED_HEARTBEAT_bp);
 650:	bf 9a       	sbi	0x17, 7	; 23
	DDR(VIBRATION_MOTOR_PORT)	|= ( 1<<VIBRATION_MOTOR_bp);
 652:	be 9a       	sbi	0x17, 6	; 23
	DDR(SOUND_PORT)				|= ( 1<<SOUND_bp);
 654:	a4 9a       	sbi	0x14, 4	; 20
	DDR(RELAIS_PORT1_PORT)		|= ((RELAIS_1_PORT1) | (RELAIS_2_PORT1) | (RELAIS_3_PORT1) | (RELAIS_4_PORT1) | (RELAIS_5_PORT1) | (RELAIS_6_PORT1));
 656:	81 b3       	in	r24, 0x11	; 17
 658:	8c 6f       	ori	r24, 0xFC	; 252
 65a:	81 bb       	out	0x11, r24	; 17
	DDR(RELAIS_PORT2_PORT)		|= ((RELAIS_7_PORT2) | (RELAIS_8_PORT2));
 65c:	84 b3       	in	r24, 0x14	; 20
 65e:	8c 60       	ori	r24, 0x0C	; 12
 660:	84 bb       	out	0x14, r24	; 20

	SOUND_DDR |= (1<<SOUND_bp);
 662:	a4 9a       	sbi	0x14, 4	; 20
	
	/* gpios as input */
	DDR(SWITCH_PORT)			&= ~((1<<SWITCH_ENTER_bp) | (1<<SWITCH_UP_bp) | (1<<SWITCH_DOWN_bp) | (1<<SWITCH_RETURN_bp));
 664:	87 b3       	in	r24, 0x17	; 23
 666:	80 7f       	andi	r24, 0xF0	; 240
 668:	87 bb       	out	0x17, r24	; 23
	DDR(MEASURE_VCC_PORT) 		&= ~( 1<<MEASURE_VCC_bp);
 66a:	d0 98       	cbi	0x1a, 0	; 26
	DDR(ENC_SWITCH_PORT)  		&= ~( 1<<ENC_SWITCH_bp);
 66c:	ac 98       	cbi	0x15, 4	; 21
	DDR(ENC_PORT)		 		&= ~((1<<ENC_A) | (1<<ENC_B));
 66e:	8a b3       	in	r24, 0x1a	; 26
 670:	89 7f       	andi	r24, 0xF9	; 249
 672:	8a bb       	out	0x1a, r24	; 26
 674:	08 95       	ret

00000676 <cmdRelais>:
	if( val > max )
	{
		return 0;
	}
	return val;
}
 676:	bf 92       	push	r11
 678:	cf 92       	push	r12
 67a:	df 92       	push	r13
 67c:	ef 92       	push	r14
 67e:	ff 92       	push	r15
 680:	0f 93       	push	r16
 682:	1f 93       	push	r17
 684:	cf 93       	push	r28
 686:	df 93       	push	r29
 688:	cd b7       	in	r28, 0x3d	; 61
 68a:	de b7       	in	r29, 0x3e	; 62
 68c:	2a 97       	sbiw	r28, 0x0a	; 10
 68e:	0f b6       	in	r0, 0x3f	; 63
 690:	f8 94       	cli
 692:	de bf       	out	0x3e, r29	; 62
 694:	0f be       	out	0x3f, r0	; 63
 696:	cd bf       	out	0x3d, r28	; 61
 698:	6c 01       	movw	r12, r24
 69a:	1a 82       	std	Y+2, r1	; 0x02
 69c:	19 82       	std	Y+1, r1	; 0x01
 69e:	fe 01       	movw	r30, r28
 6a0:	33 96       	adiw	r30, 0x03	; 3
 6a2:	88 e0       	ldi	r24, 0x08	; 8
 6a4:	df 01       	movw	r26, r30
 6a6:	1d 92       	st	X+, r1
 6a8:	8a 95       	dec	r24
 6aa:	e9 f7       	brne	.-6      	; 0x6a6 <cmdRelais+0x30>
 6ac:	40 e0       	ldi	r20, 0x00	; 0
 6ae:	b6 01       	movw	r22, r12
 6b0:	ce 01       	movw	r24, r28
 6b2:	01 96       	adiw	r24, 0x01	; 1
 6b4:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <cmdGetPara>
 6b8:	0e 94 09 05 	call	0xa12	; 0xa12 <atoi>
 6bc:	7c 01       	movw	r14, r24
 6be:	41 e0       	ldi	r20, 0x01	; 1
 6c0:	b6 01       	movw	r22, r12
 6c2:	ce 01       	movw	r24, r28
 6c4:	01 96       	adiw	r24, 0x01	; 1
 6c6:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <cmdGetPara>
 6ca:	0e 94 09 05 	call	0xa12	; 0xa12 <atoi>
 6ce:	8c 01       	movw	r16, r24
 6d0:	41 e0       	ldi	r20, 0x01	; 1
 6d2:	b6 01       	movw	r22, r12
 6d4:	ce 01       	movw	r24, r28
 6d6:	01 96       	adiw	r24, 0x01	; 1
 6d8:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <cmdGetPara>
 6dc:	0e 94 13 03 	call	0x626	; 0x626 <uart_puts>
 6e0:	c8 01       	movw	r24, r16
 6e2:	99 27       	eor	r25, r25
 6e4:	81 30       	cpi	r24, 0x01	; 1
 6e6:	91 05       	cpc	r25, r1
 6e8:	21 f1       	breq	.+72     	; 0x732 <cmdRelais+0xbc>
 6ea:	82 30       	cpi	r24, 0x02	; 2
 6ec:	91 05       	cpc	r25, r1
 6ee:	e9 f1       	breq	.+122    	; 0x76a <cmdRelais+0xf4>
 6f0:	89 2b       	or	r24, r25
 6f2:	09 f0       	breq	.+2      	; 0x6f6 <cmdRelais+0x80>
 6f4:	4e c0       	rjmp	.+156    	; 0x792 <cmdRelais+0x11c>
 6f6:	b6 e0       	ldi	r27, 0x06	; 6
 6f8:	be 15       	cp	r27, r14
 6fa:	68 f0       	brcs	.+26     	; 0x716 <cmdRelais+0xa0>
 6fc:	22 b3       	in	r18, 0x12	; 18
 6fe:	e3 94       	inc	r14
 700:	81 e0       	ldi	r24, 0x01	; 1
 702:	90 e0       	ldi	r25, 0x00	; 0
 704:	02 c0       	rjmp	.+4      	; 0x70a <cmdRelais+0x94>
 706:	88 0f       	add	r24, r24
 708:	99 1f       	adc	r25, r25
 70a:	ea 94       	dec	r14
 70c:	e2 f7       	brpl	.-8      	; 0x706 <cmdRelais+0x90>
 70e:	80 95       	com	r24
 710:	82 23       	and	r24, r18
 712:	82 bb       	out	0x12, r24	; 18
 714:	3e c0       	rjmp	.+124    	; 0x792 <cmdRelais+0x11c>
 716:	25 b3       	in	r18, 0x15	; 21
 718:	3b ef       	ldi	r19, 0xFB	; 251
 71a:	3e 0d       	add	r19, r14
 71c:	81 e0       	ldi	r24, 0x01	; 1
 71e:	90 e0       	ldi	r25, 0x00	; 0
 720:	02 c0       	rjmp	.+4      	; 0x726 <cmdRelais+0xb0>
 722:	88 0f       	add	r24, r24
 724:	99 1f       	adc	r25, r25
 726:	3a 95       	dec	r19
 728:	e2 f7       	brpl	.-8      	; 0x722 <cmdRelais+0xac>
 72a:	80 95       	com	r24
 72c:	82 23       	and	r24, r18
 72e:	85 bb       	out	0x15, r24	; 21
 730:	30 c0       	rjmp	.+96     	; 0x792 <cmdRelais+0x11c>
 732:	86 e0       	ldi	r24, 0x06	; 6
 734:	8e 15       	cp	r24, r14
 736:	60 f0       	brcs	.+24     	; 0x750 <cmdRelais+0xda>
 738:	22 b3       	in	r18, 0x12	; 18
 73a:	e3 94       	inc	r14
 73c:	81 e0       	ldi	r24, 0x01	; 1
 73e:	90 e0       	ldi	r25, 0x00	; 0
 740:	02 c0       	rjmp	.+4      	; 0x746 <cmdRelais+0xd0>
 742:	88 0f       	add	r24, r24
 744:	99 1f       	adc	r25, r25
 746:	ea 94       	dec	r14
 748:	e2 f7       	brpl	.-8      	; 0x742 <cmdRelais+0xcc>
 74a:	82 2b       	or	r24, r18
 74c:	82 bb       	out	0x12, r24	; 18
 74e:	21 c0       	rjmp	.+66     	; 0x792 <cmdRelais+0x11c>
 750:	25 b3       	in	r18, 0x15	; 21
 752:	3b ef       	ldi	r19, 0xFB	; 251
 754:	3e 0d       	add	r19, r14
 756:	81 e0       	ldi	r24, 0x01	; 1
 758:	90 e0       	ldi	r25, 0x00	; 0
 75a:	02 c0       	rjmp	.+4      	; 0x760 <cmdRelais+0xea>
 75c:	88 0f       	add	r24, r24
 75e:	99 1f       	adc	r25, r25
 760:	3a 95       	dec	r19
 762:	e2 f7       	brpl	.-8      	; 0x75c <cmdRelais+0xe6>
 764:	82 2b       	or	r24, r18
 766:	85 bb       	out	0x15, r24	; 21
 768:	14 c0       	rjmp	.+40     	; 0x792 <cmdRelais+0x11c>
 76a:	80 e1       	ldi	r24, 0x10	; 16
 76c:	91 e0       	ldi	r25, 0x01	; 1
 76e:	0e 94 13 03 	call	0x626	; 0x626 <uart_puts>
 772:	8e 2d       	mov	r24, r14
 774:	88 0f       	add	r24, r24
 776:	88 0f       	add	r24, r24
 778:	82 bb       	out	0x12, r24	; 18
 77a:	a0 ec       	ldi	r26, 0xC0	; 192
 77c:	ea 22       	and	r14, r26
 77e:	ff 24       	eor	r15, r15
 780:	f5 94       	asr	r15
 782:	e7 94       	ror	r14
 784:	f5 94       	asr	r15
 786:	e7 94       	ror	r14
 788:	f5 94       	asr	r15
 78a:	e7 94       	ror	r14
 78c:	f5 94       	asr	r15
 78e:	e7 94       	ror	r14
 790:	e5 ba       	out	0x15, r14	; 21
 792:	80 e3       	ldi	r24, 0x30	; 48
 794:	90 e0       	ldi	r25, 0x00	; 0
 796:	2a 96       	adiw	r28, 0x0a	; 10
 798:	0f b6       	in	r0, 0x3f	; 63
 79a:	f8 94       	cli
 79c:	de bf       	out	0x3e, r29	; 62
 79e:	0f be       	out	0x3f, r0	; 63
 7a0:	cd bf       	out	0x3d, r28	; 61
 7a2:	df 91       	pop	r29
 7a4:	cf 91       	pop	r28
 7a6:	1f 91       	pop	r17
 7a8:	0f 91       	pop	r16
 7aa:	ff 90       	pop	r15
 7ac:	ef 90       	pop	r14
 7ae:	df 90       	pop	r13
 7b0:	cf 90       	pop	r12
 7b2:	bf 90       	pop	r11
 7b4:	08 95       	ret

000007b6 <help>:
 7b6:	83 e2       	ldi	r24, 0x23	; 35
 7b8:	91 e0       	ldi	r25, 0x01	; 1
 7ba:	0e 94 13 03 	call	0x626	; 0x626 <uart_puts>
 7be:	0e 94 49 00 	call	0x92	; 0x92 <buildVer>
 7c2:	0e 94 13 03 	call	0x626	; 0x626 <uart_puts>
 7c6:	88 e8       	ldi	r24, 0x88	; 136
 7c8:	91 e0       	ldi	r25, 0x01	; 1
 7ca:	0e 94 13 03 	call	0x626	; 0x626 <uart_puts>
 7ce:	8e e9       	ldi	r24, 0x9E	; 158
 7d0:	92 e0       	ldi	r25, 0x02	; 2
 7d2:	0e 94 8b 01 	call	0x316	; 0x316 <cmdHelp>
 7d6:	0e 94 13 03 	call	0x626	; 0x626 <uart_puts>
 7da:	80 e0       	ldi	r24, 0x00	; 0
 7dc:	90 e0       	ldi	r25, 0x00	; 0
 7de:	08 95       	ret

000007e0 <timerInit>:
 7e0:	8e b5       	in	r24, 0x2e	; 46
 7e2:	89 60       	ori	r24, 0x09	; 9
 7e4:	8e bd       	out	0x2e, r24	; 46
 7e6:	89 b7       	in	r24, 0x39	; 57
 7e8:	80 61       	ori	r24, 0x10	; 16
 7ea:	89 bf       	out	0x39, r24	; 57
 7ec:	80 ed       	ldi	r24, 0xD0	; 208
 7ee:	97 e0       	ldi	r25, 0x07	; 7
 7f0:	9b bd       	out	0x2b, r25	; 43
 7f2:	8a bd       	out	0x2a, r24	; 42
 7f4:	08 95       	ret

000007f6 <readRingBuff>:
	
char		*readRingBuff( char *stream )					
{
 7f6:	cf 93       	push	r28
 7f8:	df 93       	push	r29
 7fa:	ec 01       	movw	r28, r24
	static uint8_t index = 0;
	
	/*
	*	Neustes Byte aus dem Ringpuffer abholen
	*/
	uint16_t c = uart_getc();
 7fc:	0e 94 e9 02 	call	0x5d2	; 0x5d2 <uart_getc>
	
	/*
	*	Wenn keine neuen Daten vorhanden, direkt wieder zurück!
	*/
	if ( c & UART_NO_DATA)
 800:	90 fd       	sbrc	r25, 0
 802:	2f c0       	rjmp	.+94     	; 0x862 <__stack+0x3>
	}
	
	/*
	*	Ist ein Fehler aufgetreten?
	*/
	if ( c > UART_NO_DATA)
 804:	81 30       	cpi	r24, 0x01	; 1
 806:	21 e0       	ldi	r18, 0x01	; 1
 808:	92 07       	cpc	r25, r18
 80a:	28 f0       	brcs	.+10     	; 0x816 <readRingBuff+0x20>
	{
		index = 0; 
 80c:	10 92 9d 02 	sts	0x029D, r1	; 0x80029d <index.2343>
		return NULL;
 810:	80 e0       	ldi	r24, 0x00	; 0
 812:	90 e0       	ldi	r25, 0x00	; 0
 814:	28 c0       	rjmp	.+80     	; 0x866 <__stack+0x7>
	}
	
	/*
	*	Status und Error Bits ausmaskieren
	*/
	c &= 0x00FF;
 816:	9c 01       	movw	r18, r24
 818:	33 27       	eor	r19, r19
	
	/*
	*	Übertragungsende?
	*/
	if ( c == '\r' || c == '\n' )
 81a:	2d 30       	cpi	r18, 0x0D	; 13
 81c:	31 05       	cpc	r19, r1
 81e:	19 f0       	breq	.+6      	; 0x826 <readRingBuff+0x30>
 820:	2a 30       	cpi	r18, 0x0A	; 10
 822:	31 05       	cpc	r19, r1
 824:	59 f4       	brne	.+22     	; 0x83c <readRingBuff+0x46>
	{
		*( stream + index ) = '\0';
 826:	80 91 9d 02 	lds	r24, 0x029D	; 0x80029d <index.2343>
 82a:	fe 01       	movw	r30, r28
 82c:	e8 0f       	add	r30, r24
 82e:	f1 1d       	adc	r31, r1
 830:	10 82       	st	Z, r1
		index = 0; 
 832:	10 92 9d 02 	sts	0x029D, r1	; 0x80029d <index.2343>
			
		return stream;
 836:	8c 2f       	mov	r24, r28
 838:	9d 2f       	mov	r25, r29
 83a:	15 c0       	rjmp	.+42     	; 0x866 <__stack+0x7>
	}
	
	/*
	*	Daten in unseren neuen Puffer zwischen speichern
	*/
	if (index >= UART_RX_BUFFER_SIZE)
 83c:	20 91 9d 02 	lds	r18, 0x029D	; 0x80029d <index.2343>
 840:	20 34       	cpi	r18, 0x40	; 64
 842:	28 f0       	brcs	.+10     	; 0x84e <readRingBuff+0x58>
	{
		index = 0;
 844:	10 92 9d 02 	sts	0x029D, r1	; 0x80029d <index.2343>
	else
	{
		*( stream + index++ ) = (uint8_t)c;	
	}
	
	return NULL;
 848:	80 e0       	ldi	r24, 0x00	; 0
 84a:	90 e0       	ldi	r25, 0x00	; 0
 84c:	0c c0       	rjmp	.+24     	; 0x866 <__stack+0x7>
	{
		index = 0;
	}
	else
	{
		*( stream + index++ ) = (uint8_t)c;	
 84e:	91 e0       	ldi	r25, 0x01	; 1
 850:	92 0f       	add	r25, r18
 852:	90 93 9d 02 	sts	0x029D, r25	; 0x80029d <index.2343>
 856:	c2 0f       	add	r28, r18
 858:	d1 1d       	adc	r29, r1
 85a:	88 83       	st	Y, r24
	}
	
	return NULL;
 85c:	80 e0       	ldi	r24, 0x00	; 0
 85e:	90 e0       	ldi	r25, 0x00	; 0
 860:	02 c0       	rjmp	.+4      	; 0x866 <__stack+0x7>
	/*
	*	Wenn keine neuen Daten vorhanden, direkt wieder zurück!
	*/
	if ( c & UART_NO_DATA)
	{
		return NULL;
 862:	80 e0       	ldi	r24, 0x00	; 0
 864:	90 e0       	ldi	r25, 0x00	; 0
	{
		*( stream + index++ ) = (uint8_t)c;	
	}
	
	return NULL;
}
 866:	df 91       	pop	r29
 868:	cf 91       	pop	r28
 86a:	08 95       	ret

0000086c <main>:



int main(void)
{
	hardware_init();
 86c:	0e 94 22 03 	call	0x644	; 0x644 <hardware_init>
	
	uart_init( UART_BAUD_SELECT( 9600 , F_CPU ) );
 870:	87 e6       	ldi	r24, 0x67	; 103
 872:	90 e0       	ldi	r25, 0x00	; 0
 874:	0e 94 d5 02 	call	0x5aa	; 0x5aa <uart_init>
	
	timerInit();
 878:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <timerInit>

	sei();
 87c:	78 94       	sei

	uart_puts( "**RelaisSwitchBoard**\r\n");
 87e:	8a e2       	ldi	r24, 0x2A	; 42
 880:	91 e0       	ldi	r25, 0x01	; 1
 882:	0e 94 13 03 	call	0x626	; 0x626 <uart_puts>
	uart_puts( "Support by J.H - Elec.\r\n");
 886:	82 e4       	ldi	r24, 0x42	; 66
 888:	91 e0       	ldi	r25, 0x01	; 1
 88a:	0e 94 13 03 	call	0x626	; 0x626 <uart_puts>
	uart_puts( "www.jh-elec.de\r\n" );
 88e:	8b e5       	ldi	r24, 0x5B	; 91
 890:	91 e0       	ldi	r25, 0x01	; 1
 892:	0e 94 13 03 	call	0x626	; 0x626 <uart_puts>
	uart_puts( "Ver.: " );
 896:	83 e2       	ldi	r24, 0x23	; 35
 898:	91 e0       	ldi	r25, 0x01	; 1
 89a:	0e 94 13 03 	call	0x626	; 0x626 <uart_puts>
	uart_puts( buildVer() );
 89e:	0e 94 49 00 	call	0x92	; 0x92 <buildVer>
 8a2:	0e 94 13 03 	call	0x626	; 0x626 <uart_puts>
	uart_puts( "\r\n\n" );
 8a6:	8c e0       	ldi	r24, 0x0C	; 12
 8a8:	91 e0       	ldi	r25, 0x01	; 1
 8aa:	0e 94 13 03 	call	0x626	; 0x626 <uart_puts>

	cmdInit( cmdTab , &raw , CMD_TAB_SIZE( cmdTab ) );
 8ae:	42 e0       	ldi	r20, 0x02	; 2
 8b0:	50 e0       	ldi	r21, 0x00	; 0
 8b2:	68 ed       	ldi	r22, 0xD8	; 216
 8b4:	73 e0       	ldi	r23, 0x03	; 3
 8b6:	83 ee       	ldi	r24, 0xE3	; 227
 8b8:	91 e0       	ldi	r25, 0x01	; 1
 8ba:	0e 94 ca 00 	call	0x194	; 0x194 <cmdInit>
	char *streamPtr		= NULL;
	const char *cmdPtr	= NULL;
	
	while (1) 
    {	
		streamPtr = readRingBuff( streamIn );
 8be:	88 e9       	ldi	r24, 0x98	; 152
 8c0:	93 e0       	ldi	r25, 0x03	; 3
 8c2:	0e 94 fb 03 	call	0x7f6	; 0x7f6 <readRingBuff>
		
		if ( streamPtr != NULL )
 8c6:	00 97       	sbiw	r24, 0x00	; 0
 8c8:	d1 f3       	breq	.-12     	; 0x8be <main+0x52>
		{
			cmdPtr = cmdGetName( streamPtr );
 8ca:	0e 94 d3 00 	call	0x1a6	; 0x1a6 <cmdGetName>
 8ce:	ec 01       	movw	r28, r24

			if ( cmdPtr != NULL  )
 8d0:	89 2b       	or	r24, r25
 8d2:	21 f1       	breq	.+72     	; 0x91c <main+0xb0>
			{
				uart_puts( "****************************\r\n" );
 8d4:	8c e6       	ldi	r24, 0x6C	; 108
 8d6:	91 e0       	ldi	r25, 0x01	; 1
 8d8:	0e 94 13 03 	call	0x626	; 0x626 <uart_puts>
		
				void *(*funcPtr)(void*,void*) = cmdGetFunc( streamIn );
 8dc:	88 e9       	ldi	r24, 0x98	; 152
 8de:	93 e0       	ldi	r25, 0x03	; 3
 8e0:	0e 94 e6 00 	call	0x1cc	; 0x1cc <cmdGetFunc>
 8e4:	8c 01       	movw	r16, r24
				if ( funcPtr != NULL )
 8e6:	89 2b       	or	r24, r25
 8e8:	a1 f0       	breq	.+40     	; 0x912 <main+0xa6>
				{
					uart_puts( cmdPtr ); // Namen der Funktion ausgeben
 8ea:	ce 01       	movw	r24, r28
 8ec:	0e 94 13 03 	call	0x626	; 0x626 <uart_puts>
					
					if ( funcPtr( streamIn , NULL ) != NULL )
 8f0:	60 e0       	ldi	r22, 0x00	; 0
 8f2:	70 e0       	ldi	r23, 0x00	; 0
 8f4:	88 e9       	ldi	r24, 0x98	; 152
 8f6:	93 e0       	ldi	r25, 0x03	; 3
 8f8:	f8 01       	movw	r30, r16
 8fa:	09 95       	icall
 8fc:	89 2b       	or	r24, r25
 8fe:	29 f0       	breq	.+10     	; 0x90a <main+0x9e>
					{
						uart_puts( "CMD_OK\r\n" );
 900:	8b e8       	ldi	r24, 0x8B	; 139
 902:	91 e0       	ldi	r25, 0x01	; 1
 904:	0e 94 13 03 	call	0x626	; 0x626 <uart_puts>
 908:	04 c0       	rjmp	.+8      	; 0x912 <main+0xa6>
					}
					else
					{
						uart_puts( "CMD_BAD\r\n" );
 90a:	84 e9       	ldi	r24, 0x94	; 148
 90c:	91 e0       	ldi	r25, 0x01	; 1
 90e:	0e 94 13 03 	call	0x626	; 0x626 <uart_puts>
// 					uart_puts( "CRC.: " );
// 					uart_puts( crcPtr );
// 					uart_puts( "\r\n" );
// 				}
						
				uart_puts( "****************************\r\n" );				
 912:	8c e6       	ldi	r24, 0x6C	; 108
 914:	91 e0       	ldi	r25, 0x01	; 1
 916:	0e 94 13 03 	call	0x626	; 0x626 <uart_puts>
 91a:	d1 cf       	rjmp	.-94     	; 0x8be <main+0x52>
			}
			else
			{
				uart_puts( "no command\r\n" );
 91c:	8e e9       	ldi	r24, 0x9E	; 158
 91e:	91 e0       	ldi	r25, 0x01	; 1
 920:	0e 94 13 03 	call	0x626	; 0x626 <uart_puts>
				uart_puts( "Loopback: " );
 924:	8b ea       	ldi	r24, 0xAB	; 171
 926:	91 e0       	ldi	r25, 0x01	; 1
 928:	0e 94 13 03 	call	0x626	; 0x626 <uart_puts>
				uart_puts( streamIn );
 92c:	88 e9       	ldi	r24, 0x98	; 152
 92e:	93 e0       	ldi	r25, 0x03	; 3
 930:	0e 94 13 03 	call	0x626	; 0x626 <uart_puts>
				uart_puts( "\r\n" );
 934:	88 e8       	ldi	r24, 0x88	; 136
 936:	91 e0       	ldi	r25, 0x01	; 1
 938:	0e 94 13 03 	call	0x626	; 0x626 <uart_puts>
 93c:	c0 cf       	rjmp	.-128    	; 0x8be <main+0x52>

0000093e <__vector_7>:
    }
}

/* live the CPU?*/
ISR(TIMER1_COMPA_vect)
{
 93e:	1f 92       	push	r1
 940:	0f 92       	push	r0
 942:	0f b6       	in	r0, 0x3f	; 63
 944:	0f 92       	push	r0
 946:	11 24       	eor	r1, r1
 948:	2f 93       	push	r18
 94a:	4f 93       	push	r20
 94c:	5f 93       	push	r21
 94e:	6f 93       	push	r22
 950:	7f 93       	push	r23
 952:	8f 93       	push	r24
 954:	9f 93       	push	r25
 956:	af 93       	push	r26
 958:	bf 93       	push	r27
	static uint32_t stateLED = 0;
	
	/*
	*	Status Anzeige
	*/
	stateLED = checkMaxValue( ++stateLED , 10e3 );
 95a:	80 91 99 02 	lds	r24, 0x0299	; 0x800299 <stateLED.2359>
 95e:	90 91 9a 02 	lds	r25, 0x029A	; 0x80029a <stateLED.2359+0x1>
 962:	a0 91 9b 02 	lds	r26, 0x029B	; 0x80029b <stateLED.2359+0x2>
 966:	b0 91 9c 02 	lds	r27, 0x029C	; 0x80029c <stateLED.2359+0x3>
 96a:	01 96       	adiw	r24, 0x01	; 1
 96c:	a1 1d       	adc	r26, r1
 96e:	b1 1d       	adc	r27, r1
	OCR1A   = ( (uint16_t)( F_CPU / 1 / 8000 ) );	
}

uint16_t	checkMaxValue( uint16_t val , uint16_t max )	
{
	if( val > max )
 970:	81 31       	cpi	r24, 0x11	; 17
 972:	27 e2       	ldi	r18, 0x27	; 39
 974:	92 07       	cpc	r25, r18
 976:	b0 f5       	brcc	.+108    	; 0x9e4 <__vector_7+0xa6>
 978:	aa 27       	eor	r26, r26
 97a:	bb 27       	eor	r27, r27
	static uint32_t stateLED = 0;
	
	/*
	*	Status Anzeige
	*/
	stateLED = checkMaxValue( ++stateLED , 10e3 );
 97c:	80 93 99 02 	sts	0x0299, r24	; 0x800299 <stateLED.2359>
 980:	90 93 9a 02 	sts	0x029A, r25	; 0x80029a <stateLED.2359+0x1>
 984:	a0 93 9b 02 	sts	0x029B, r26	; 0x80029b <stateLED.2359+0x2>
 988:	b0 93 9c 02 	sts	0x029C, r27	; 0x80029c <stateLED.2359+0x3>
	
	if ( stateLED <= 200 )
 98c:	89 3c       	cpi	r24, 0xC9	; 201
 98e:	91 05       	cpc	r25, r1
 990:	a1 05       	cpc	r26, r1
 992:	b1 05       	cpc	r27, r1
 994:	10 f4       	brcc	.+4      	; 0x99a <__vector_7+0x5c>
	{
		BC(LED_HEARTBEAT_PORT,LED_HEARTBEAT_bp);
 996:	c7 98       	cbi	0x18, 7	; 24
 998:	2e c0       	rjmp	.+92     	; 0x9f6 <__vector_7+0xb8>
	}
	else if ( ( stateLED >= 400 ) && ( stateLED <= 600 ) )
 99a:	ac 01       	movw	r20, r24
 99c:	bd 01       	movw	r22, r26
 99e:	40 59       	subi	r20, 0x90	; 144
 9a0:	51 40       	sbci	r21, 0x01	; 1
 9a2:	61 09       	sbc	r22, r1
 9a4:	71 09       	sbc	r23, r1
 9a6:	49 3c       	cpi	r20, 0xC9	; 201
 9a8:	51 05       	cpc	r21, r1
 9aa:	61 05       	cpc	r22, r1
 9ac:	71 05       	cpc	r23, r1
 9ae:	10 f4       	brcc	.+4      	; 0x9b4 <__vector_7+0x76>
	{
		BS(LED_HEARTBEAT_PORT,LED_HEARTBEAT_bp);
 9b0:	c7 9a       	sbi	0x18, 7	; 24
 9b2:	21 c0       	rjmp	.+66     	; 0x9f6 <__vector_7+0xb8>
	}
	else if ( ( stateLED >= 1000 ) && ( stateLED <= 1400 ) )
 9b4:	ac 01       	movw	r20, r24
 9b6:	bd 01       	movw	r22, r26
 9b8:	48 5e       	subi	r20, 0xE8	; 232
 9ba:	53 40       	sbci	r21, 0x03	; 3
 9bc:	61 09       	sbc	r22, r1
 9be:	71 09       	sbc	r23, r1
 9c0:	41 39       	cpi	r20, 0x91	; 145
 9c2:	51 40       	sbci	r21, 0x01	; 1
 9c4:	61 05       	cpc	r22, r1
 9c6:	71 05       	cpc	r23, r1
 9c8:	10 f4       	brcc	.+4      	; 0x9ce <__vector_7+0x90>
	{
		BC(LED_HEARTBEAT_PORT,LED_HEARTBEAT_bp);
 9ca:	c7 98       	cbi	0x18, 7	; 24
 9cc:	14 c0       	rjmp	.+40     	; 0x9f6 <__vector_7+0xb8>
	}
	else if ( ( stateLED >= 1600 ) && ( stateLED <= 1800 ) )
 9ce:	80 54       	subi	r24, 0x40	; 64
 9d0:	96 40       	sbci	r25, 0x06	; 6
 9d2:	a1 09       	sbc	r26, r1
 9d4:	b1 09       	sbc	r27, r1
 9d6:	89 3c       	cpi	r24, 0xC9	; 201
 9d8:	91 05       	cpc	r25, r1
 9da:	a1 05       	cpc	r26, r1
 9dc:	b1 05       	cpc	r27, r1
 9de:	58 f4       	brcc	.+22     	; 0x9f6 <__vector_7+0xb8>
	{
		BS(LED_HEARTBEAT_PORT,LED_HEARTBEAT_bp);
 9e0:	c7 9a       	sbi	0x18, 7	; 24
	}
 9e2:	09 c0       	rjmp	.+18     	; 0x9f6 <__vector_7+0xb8>
	static uint32_t stateLED = 0;
	
	/*
	*	Status Anzeige
	*/
	stateLED = checkMaxValue( ++stateLED , 10e3 );
 9e4:	10 92 99 02 	sts	0x0299, r1	; 0x800299 <stateLED.2359>
 9e8:	10 92 9a 02 	sts	0x029A, r1	; 0x80029a <stateLED.2359+0x1>
 9ec:	10 92 9b 02 	sts	0x029B, r1	; 0x80029b <stateLED.2359+0x2>
 9f0:	10 92 9c 02 	sts	0x029C, r1	; 0x80029c <stateLED.2359+0x3>
 9f4:	d0 cf       	rjmp	.-96     	; 0x996 <__vector_7+0x58>
	}
	else if ( ( stateLED >= 1600 ) && ( stateLED <= 1800 ) )
	{
		BS(LED_HEARTBEAT_PORT,LED_HEARTBEAT_bp);
	}
 9f6:	bf 91       	pop	r27
 9f8:	af 91       	pop	r26
 9fa:	9f 91       	pop	r25
 9fc:	8f 91       	pop	r24
 9fe:	7f 91       	pop	r23
 a00:	6f 91       	pop	r22
 a02:	5f 91       	pop	r21
 a04:	4f 91       	pop	r20
 a06:	2f 91       	pop	r18
 a08:	0f 90       	pop	r0
 a0a:	0f be       	out	0x3f, r0	; 63
 a0c:	0f 90       	pop	r0
 a0e:	1f 90       	pop	r1
 a10:	18 95       	reti

00000a12 <atoi>:
 a12:	fc 01       	movw	r30, r24
 a14:	88 27       	eor	r24, r24
 a16:	99 27       	eor	r25, r25
 a18:	e8 94       	clt
 a1a:	21 91       	ld	r18, Z+
 a1c:	20 32       	cpi	r18, 0x20	; 32
 a1e:	e9 f3       	breq	.-6      	; 0xa1a <atoi+0x8>
 a20:	29 30       	cpi	r18, 0x09	; 9
 a22:	10 f0       	brcs	.+4      	; 0xa28 <atoi+0x16>
 a24:	2e 30       	cpi	r18, 0x0E	; 14
 a26:	c8 f3       	brcs	.-14     	; 0xa1a <atoi+0x8>
 a28:	2b 32       	cpi	r18, 0x2B	; 43
 a2a:	41 f0       	breq	.+16     	; 0xa3c <atoi+0x2a>
 a2c:	2d 32       	cpi	r18, 0x2D	; 45
 a2e:	39 f4       	brne	.+14     	; 0xa3e <atoi+0x2c>
 a30:	68 94       	set
 a32:	04 c0       	rjmp	.+8      	; 0xa3c <atoi+0x2a>
 a34:	0e 94 5e 05 	call	0xabc	; 0xabc <__mulhi_const_10>
 a38:	82 0f       	add	r24, r18
 a3a:	91 1d       	adc	r25, r1
 a3c:	21 91       	ld	r18, Z+
 a3e:	20 53       	subi	r18, 0x30	; 48
 a40:	2a 30       	cpi	r18, 0x0A	; 10
 a42:	c0 f3       	brcs	.-16     	; 0xa34 <atoi+0x22>
 a44:	1e f4       	brtc	.+6      	; 0xa4c <atoi+0x3a>
 a46:	90 95       	com	r25
 a48:	81 95       	neg	r24
 a4a:	9f 4f       	sbci	r25, 0xFF	; 255
 a4c:	08 95       	ret

00000a4e <memset>:
 a4e:	dc 01       	movw	r26, r24
 a50:	01 c0       	rjmp	.+2      	; 0xa54 <memset+0x6>
 a52:	6d 93       	st	X+, r22
 a54:	41 50       	subi	r20, 0x01	; 1
 a56:	50 40       	sbci	r21, 0x00	; 0
 a58:	e0 f7       	brcc	.-8      	; 0xa52 <memset+0x4>
 a5a:	08 95       	ret

00000a5c <strcat>:
 a5c:	fb 01       	movw	r30, r22
 a5e:	dc 01       	movw	r26, r24
 a60:	0d 90       	ld	r0, X+
 a62:	00 20       	and	r0, r0
 a64:	e9 f7       	brne	.-6      	; 0xa60 <strcat+0x4>
 a66:	11 97       	sbiw	r26, 0x01	; 1
 a68:	01 90       	ld	r0, Z+
 a6a:	0d 92       	st	X+, r0
 a6c:	00 20       	and	r0, r0
 a6e:	e1 f7       	brne	.-8      	; 0xa68 <strcat+0xc>
 a70:	08 95       	ret

00000a72 <strchr>:
 a72:	fc 01       	movw	r30, r24
 a74:	81 91       	ld	r24, Z+
 a76:	86 17       	cp	r24, r22
 a78:	21 f0       	breq	.+8      	; 0xa82 <strchr+0x10>
 a7a:	88 23       	and	r24, r24
 a7c:	d9 f7       	brne	.-10     	; 0xa74 <strchr+0x2>
 a7e:	99 27       	eor	r25, r25
 a80:	08 95       	ret
 a82:	31 97       	sbiw	r30, 0x01	; 1
 a84:	cf 01       	movw	r24, r30
 a86:	08 95       	ret

00000a88 <strstr>:
 a88:	fb 01       	movw	r30, r22
 a8a:	51 91       	ld	r21, Z+
 a8c:	55 23       	and	r21, r21
 a8e:	a9 f0       	breq	.+42     	; 0xaba <strstr+0x32>
 a90:	bf 01       	movw	r22, r30
 a92:	dc 01       	movw	r26, r24
 a94:	4d 91       	ld	r20, X+
 a96:	45 17       	cp	r20, r21
 a98:	41 11       	cpse	r20, r1
 a9a:	e1 f7       	brne	.-8      	; 0xa94 <strstr+0xc>
 a9c:	59 f4       	brne	.+22     	; 0xab4 <strstr+0x2c>
 a9e:	cd 01       	movw	r24, r26
 aa0:	01 90       	ld	r0, Z+
 aa2:	00 20       	and	r0, r0
 aa4:	49 f0       	breq	.+18     	; 0xab8 <strstr+0x30>
 aa6:	4d 91       	ld	r20, X+
 aa8:	40 15       	cp	r20, r0
 aaa:	41 11       	cpse	r20, r1
 aac:	c9 f3       	breq	.-14     	; 0xaa0 <strstr+0x18>
 aae:	fb 01       	movw	r30, r22
 ab0:	41 11       	cpse	r20, r1
 ab2:	ef cf       	rjmp	.-34     	; 0xa92 <strstr+0xa>
 ab4:	81 e0       	ldi	r24, 0x01	; 1
 ab6:	90 e0       	ldi	r25, 0x00	; 0
 ab8:	01 97       	sbiw	r24, 0x01	; 1
 aba:	08 95       	ret

00000abc <__mulhi_const_10>:
 abc:	7a e0       	ldi	r23, 0x0A	; 10
 abe:	97 9f       	mul	r25, r23
 ac0:	90 2d       	mov	r25, r0
 ac2:	87 9f       	mul	r24, r23
 ac4:	80 2d       	mov	r24, r0
 ac6:	91 0d       	add	r25, r1
 ac8:	11 24       	eor	r1, r1
 aca:	08 95       	ret

00000acc <_exit>:
 acc:	f8 94       	cli

00000ace <__stop_program>:
 ace:	ff cf       	rjmp	.-2      	; 0xace <__stop_program>
